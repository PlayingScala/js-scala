\documentclass[runningheads,a4paper]{llncs}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}

\usepackage[utf8]{inputenc}
\usepackage[unicode=true,hidelinks]{hyperref}

\usepackage{url}
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\include{macros}

\newcommand{\ie}{\emph{i.e.}}
\newcommand{\eg}{\emph{e.g.}}
\newcommand{\cf}{\emph{cf.~}}
\newcommand{\etal}{\emph{et al.~}}
\newcommand{\etc}{\emph{etc.}}
\newcommand{\aka}{\emph{a.k.a.}}


\begin{document}

\mainmatter

\title{FFI Is Not Enough. We Need Dependent Types}
\titlerunning{Dependent Types Rock}

\author{Julien Richard-Foy \and Olivier Barais\and Jean-Marc Jézéquel}
\authorrunning{Julien Richard-Foy \emph{et. al.}}

\institute{IRISA, Université de Rennes 1, France. \texttt{\{first\}.\{last\}@irisa.fr}}

%\toctitle{Lecture Notes in Computer Science}
%\tocauthor{Authors' Instructions}
\maketitle


\begin{abstract}
JavaScript sucks. It is a known fact. Several other programming languages can target JavaScript as a back-end,
alleviating developers from the burden of writing and maintaining JavaScript code. The Web browser APIs,
which are needed to interact with a Web page, are designed for JavaScript, making it challenging to expose them in a
statically typed language. Indeed, existing statically typed languages either loose control or loose type safety.
How to give users the same level of control as if they were using the native Web APIs, but in a statically typed and
convenient way? This article shows how dependent type systems can help.
\keywords{Dependent Types}
\end{abstract}


\section{Introduction}

Web applications are attractive because they require no installation or deployment step on clients and enable large
scale collaborative experiences. However, writing large Web applications is known to be
difficult~\cite{Mikkonen08_SpaghettiJs,Preciado05_RIAMethodologyNecessity}. One challenge comes from the fact that
the JavaScript programming language -- which is currently the only action language natively supported by almost all
Web clients -- lacks of constructs making large code bases maintainable (\eg static typing, first-class modules).

One solution consists in considering JavaScript as an assembly language\footnote{\cf
\href{http://asmjs.org/}{http://asmjs.org/}} and generating JavaScript from compilers of full-featured and
cutting-edge programming languages. Incidentally, an increasing number of programming languages or compiler backends
can generate JavaScript code (\eg Java/GWT~\cite{Chaganti07_GWT},
SharpKit\footnote{\href{http://sharpkit.net}{http://sharpkit.net}}, Dart~\cite{Griffith11_Dart},
Kotlin\footnote{\href{http://kotlin.jetbrains.org/}{http://kotlin.jetbrains.org/}},
ClojureScript~\cite{McGranaghan11_ClojureScript}, Fay\footnote{\href{http://fay-lang.org/}{http://fay-lang.org/}},
Haxe~\cite{Cannasse08_HaXe}, Opa\footnote{\href{http://opalang.org/}{http://opalang.org/}}).

However, compiling to JavaScript is not enough. Developers also need the Web browser programming environment: they
need to interact with the Web page, to build DOM fragments, to listen to user events, \etc. A Foreign Function
Interface mechanism could be used to make browser’s APIs available to the developers. However, JavaScript APIs are
not statically typed and make a heavy use of overloading, making them hard to expose in a statically typed language.

Indeed, existing statically typed languages compiling to JavaScript often expose weaker types than they should. For
instance, the function \code{createElement} is polymorphic in its return type: it can return a \code{DivElement} as
well as an \code{InputElement}, among others, but the Dart, Fay, SharpKit and Kotlin APIs return the super-type of
all the possible values, namely the \code{Element} type. As a consequence, developers need to explicitly down-cast
the value they get, which is a tedious and error prone task.

Some other languages try to workaround this problem by using overloading instead of polymorphism. For instance, HaXe
provides functions \code{createDivElement}, \code{createInputElement}, which return a \code{DivElement} and an
\code{InputElement}, respectively. Besides requiring a higher effort to implement, this solution also reduces the
control level of users: by being statically resolved, the element type can not anymore be passed as a parameter.

It turns out that most of the existing statically typed languages compiling to JavaScript either loose control or
loose type safety when they expose Web browser’s APIs. How to give developers the same level of control as if they
were using the native Web APIs, but in a statically typed and convenient way?

In this paper we present several ways to integrate Web browser’s APIs as statically typed APIs that are safe and
give developers the same control level as if they were using the native APIs. We can achieve this by using advanced
features of type systems like dependent types and functional dependencies.

\section{Motivating Example}

Typical tasks involved in Web applications.

Why is it difficult to type Web browser’s APIs?

\section{Lightweight Modular Staging}

\section{Contribution}

\subsection{Events}

Path-dependent types to abstract over an event name and its data type.

\subsection{Selectors}

\begin{itemize}
 \item Less type annotations on DOM queries, less chance to write nonsense casts
 \item Inference-driving macros help inferring more specific types
\end{itemize}

\subsection{DOM}

?

\section{Evaluation}

\subsection{Events}

Other languages either provide loose information about the data type of the listened event (Dart) or give no way to
abstract over an event (GWT, Kotlin).

\section{Conclusion and Perspectives}

\begin{thebibliography}{4}

\bibitem{jour} Smith, T.F., Waterman, M.S.: Identification of Common Molecular
Subsequences. J. Mol. Biol. 147, 195--197 (1981)

\bibitem{lncschap} May, P., Ehrlich, H.C., Steinke, T.: ZIB Structure Prediction Pipeline:
Composing a Complex Biological Workflow through Web Services. In: Nagel,
W.E., Walter, W.V., Lehner, W. (eds.) Euro-Par 2006. LNCS, vol. 4128,
pp. 1148--1158. Springer, Heidelberg (2006)

\bibitem{book} Foster, I., Kesselman, C.: The Grid: Blueprint for a New Computing
Infrastructure. Morgan Kaufmann, San Francisco (1999)

\bibitem{proceeding1} Czajkowski, K., Fitzgerald, S., Foster, I., Kesselman, C.: Grid
Information Services for Distributed Resource Sharing. In: 10th IEEE
International Symposium on High Performance Distributed Computing, pp.
181--184. IEEE Press, New York (2001)

\bibitem{proceeding2} Foster, I., Kesselman, C., Nick, J., Tuecke, S.: The Physiology of the
Grid: an Open Grid Services Architecture for Distributed Systems
Integration. Technical report, Global Grid Forum (2002)

\bibitem{url} National Center for Biotechnology Information, \url{http://www.ncbi.nlm.nih.gov}

\end{thebibliography}

\end{document}
