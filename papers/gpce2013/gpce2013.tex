\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage[unicode=true,hidelinks]{hyperref}


\newcommand{\ie}{\emph{i.e.}}
\newcommand{\eg}{\emph{e.g.}}
\newcommand{\cf}{\emph{cf.~}}
\newcommand{\etal}{\emph{et al.~}}
\newcommand{\etc}{\emph{etc.}}
\newcommand{\aka}{\emph{a.k.a.}}


\begin{document}

\conferenceinfo{GPCE '13}{October 27--28, 2013, Indianapolis, Indiana, USA} 
\copyrightyear{2013}
\copyrightdata{[to be supplied]} 

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Title Text}
\subtitle{Subtitle Text, if any}

\authorinfo{Julien Richard-Foy\and Olivier Barais\and Jean-Marc Jézéquel}
           {IRISA, Université de Rennes 1}
           {\{firstname\}.\{lastname\}@irisa.fr}

\maketitle

\begin{abstract}
This is the text of the abstract.
\end{abstract}

\category{CR-number}{subcategory}{third-level}

\terms
term1, term2

\keywords
keyword1, keyword2

\section{Introduction}

Rich Internet Applications have interesting properties: they require no installation or deployment on
clients and enables large scale collaborative experiences. However, writing large Web applications is known to be
difficult~\cite{Mikkonen08_SpaghettiJs,Preciado05_RIAMethodologyNecessity}. One challenge comes from the fact
that the business logic is scattered into heterogeneous client-side and server-side
environments~\cite{Echeverria09_RIA,Kuuskeri09_PartitioningClientServer}. For instance, HTML fragments may be
built from the server-side when a page is requested by a client, but they may also be built from the client-side to
perform an incremental update subsequent to a user action. How could developers write HTML fragment definitions once
and render them on both client-side and server-side? The more interactive the application is, the more logic needs to
be duplicated between the server-side and the client-side.

Using the same programming language on both server-side and client-side could reduce the gap between client-side and
server-side environments, however the JavaScript language -- which is currently the only action language natively
supported by all Web browsers -- has several drawbacks making it hardly suitable for large code bases (\eg no static
typing, no module system, verbose syntax, \etc). An increasing number of programming languages support generating
JavaScript (\eg GWT, SharpKit\footnote{\href{http://sharpkit.net}{http://sharpkit.net}}, Dart,
Kotlin\footnote{\href{http://kotlin.jetbrains.org/}{http://kotlin.jetbrains.org/}},
ClojureScript~\cite{McGranaghan11_ClojureScript}, Fay\footnote{\href{http://fay-lang.org/}{http://fay-lang.org/}},
Haxe~\cite{Cannasse08_HaXe} or Opa\footnote{\href{http://opalang.org/}{http://opalang.org/}}), increasing the panel
of programming languages available to write both the client-side and the server-side code of a Web application.

Having a full featured, cutting edge, programming language that runs on both client-side and server-side can help
developers to write more maintainable code, however by abstracting over the differences of the client-side and the
server-side environments, the code may suffer from performance issues. Performance is a primary concern in Web
applications, because they are supposed to run on a broad range of devices, from the powerful desktop personal
computer to the less powerful smartphone. “Every 100~ms delay costs 1\% of sales”, said Amazon in 2006.

For instance, the boundaries of the code parts to emit on client-side are less visible when you share code between
client-side and server-side so transitive dependencies may pull a lot of code, causing a high download overhead.
Moreover, generating efficient code for heterogeneous platforms is hard to achieve in an extensible way. (TODO Give a
concrete example for each problem)

On one hand, for engineering reasons, developers want to write Web applications using a single programming language,
abstracting over the target platforms differences. But on the other hand, for performance reasons, they want to keep
control on the way their code is compiled to each target platform. How to solve this dilemma?

Lightweight Modular Staging~\cite{Rompf12_LMSThesis} is a framework for defining deeply embedded DSLs in Scala. It
has been used to define high-performance DSLs for parallel computing~\cite{Brown11_Parallel} and can be used to
generate JavaScript code~\cite{Kossakowski12_JsDESL}.

On top of this previous work, this paper presents several new APIs (?) that can be shared between client-side and
server-side code and/or that are efficiently translated on each target platform. More precisely, our contributions
are:

\begin{itemize}
 \item Type-directed ad-hoc polymorphism on client-side without runtime dynamic dispatch logic;
 \item Use monads without extra container object creation;
 \item Ability to define DOM fragments using a common language for server-side and client-side, but that generates
code using standard APIs on both server-side and client-side ;
 \item An API for searching in the DOM, that exposes a single entry point but that generates code potentially using
more optimized native APIs
\end{itemize}

The remainder of this paper is organized as follows. The next section introduces existing approaches for defining
cross-compiling languages. Section \ref{contribution} presents our contribution. Section \ref{validation} evaluates
our contribution. Section \ref{discussion} concludes.

\section{Related Works}

\subsection{Fat Languages}

\subsection{Thin Languages}

\subsection{Deeply Embedded Languages}

\section{High-Level Abstractions Generating Efficient (and Heterogeneous) Code}
\label{contribution}

\subsection{Ad-Hoc Polymorphism}

\subsection{Monads Sequencing}

\subsection{DOM Fragments}

\subsection{Selectors}

\section{Implementation}

\section{Evaluation}
\label{validation}

\subsection{Real World Application}

Chooze.

\subsection{Several Implementations}

\subsubsection{Vanilla JavaScript}

\subsubsection{jQuery}

\subsubsection{GWT}

\subsubsection{SharpKit}

\subsubsection{Js-Scala}

\subsection{Benchmarks, Code Metrics}

\section{Conclusion, Future Work}
\label{discussion}

%\appendix
%\section{Appendix Title}
%
%This is the text of the appendix, if you need one.
%
\acks

Acknowledgments, if needed.

\bibliographystyle{abbrvnat}
\bibliography{biblio}
%\begin{thebibliography}{}
%\softraggedright
%
%\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
%P. Q. Smith, and X. Y. Jones. ...reference text...
%
%\end{thebibliography}
%
\end{document}
