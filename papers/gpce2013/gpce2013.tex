\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage[unicode=true,hidelinks]{hyperref}


\newcommand{\ie}{\emph{i.e.}}
\newcommand{\eg}{\emph{e.g.}}
\newcommand{\cf}{\emph{cf.~}}
\newcommand{\etal}{\emph{et al.~}}
\newcommand{\etc}{\emph{etc.}}
\newcommand{\aka}{\emph{a.k.a.}}


\begin{document}

\conferenceinfo{GPCE '13}{October 27--28, 2013, Indianapolis, Indiana, USA} 
\copyrightyear{2013}
\copyrightdata{[to be supplied]} 

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Title Text}
\subtitle{You don’t have to trade abstraction for control}

\authorinfo{Julien Richard-Foy\and Olivier Barais\and Jean-Marc Jézéquel}
           {IRISA, Université de Rennes 1}
           {\{firstname\}.\{lastname\}@irisa.fr}

\maketitle

\begin{abstract}
This is the text of the abstract.
\end{abstract}

\category{CR-number}{subcategory}{third-level}

\terms
term1, term2

\keywords
keyword1, keyword2

\section{Introduction}

Web applications are attractive because they require no installation or deployment on clients and enable large scale
collaborative experiences. However, writing large Web applications is known to be
difficult~\cite{Mikkonen08_SpaghettiJs,Preciado05_RIAMethodologyNecessity}. One challenge comes from the fact
that the business logic is scattered into heterogeneous client-side and server-side
environments~\cite{Echeverria09_RIA,Kuuskeri09_PartitioningClientServer}. This gives less flexibility in the
engineering process and requires a higher maintainance effort: once you decided to implement a feature on
client-side, changing your *mind* means completely rewriting the feature on server-side (and \emph{vice versa}).
Even worse, logic parts that need to run on both client-side and server-side are duplicated. For instance HTML
fragments may be built from the server-side when a page is requested by a client, but they may also be built from the
client-side to perform an incremental update subsequent to an user action. How could developers write HTML fragment
definitions once and render them on both client-side and server-side? The more interactive the application is, the
more logic needs to be duplicated between the server-side and the client-side (explain why?).

Using the same programming language on both server-side and client-side can improve the software engineering
process by enabling code reuse between both sides. Incidentally, the JavaScript language -- which is currently the
only action language natively supported by almost all Web clients -- can be used on server-side, and an increasing
number of programming languages or compiler backends can generate JavaScript code (\eg
Java/GWT~\cite{Chaganti07_GWT}, SharpKit\footnote{\href{http://sharpkit.net}{http://sharpkit.net}},
Dart~\cite{Griffith11_Dart}, Kotlin\footnote{\href{http://kotlin.jetbrains.org/}{http://kotlin.jetbrains.org/}},
ClojureScript~\cite{McGranaghan11_ClojureScript}, Fay\footnote{\href{http://fay-lang.org/}{http://fay-lang.org/}},
Haxe~\cite{Cannasse08_HaXe} or Opa\footnote{\href{http://opalang.org/}{http://opalang.org/}}).

However, this engineering comfort may come at the price of an inefficient runtime: abstracting over platform
differences often means restricting to a subset of common features and losing opportunities to perform platform
specific optimizations. Performance is a primary concern in Web applications, because they are expected to run on a
broad range of devices, from the powerful desktop personal computer to the less powerful smartphone. “Every 100~ms
delay costs 1\% of sales”, said Amazon in 2006. For instance, because the boundaries of the code sent to the client
are less visible when you share code between client-side and server-side, transitive dependencies may pull a lot of
code on the client, causing a high download overhead. Moreover, generating efficient code for heterogeneous platforms
is hard to achieve in an extensible way: the translation of common abstractions like collections into their native
counterpart (JavaScript arrays on client-side and standard library’s collections on server-side) may be hardcoded in
the compiler, but that would not scale to handle all the abstractions a complete application may use (\eg HTML
fragment definitions, form validation rules, or even some business data type that may be represented differently for
performance reasons).

On one hand, for engineering reasons, developers want to write Web applications using a single language, abstracting
over the target platforms differences. But on the other hand, for performance reasons, they want to keep
control on the way their code is compiled to each target platform. How to solve this dilemma?

Compiled domain specific embedded languages~\cite{Elliott2003_Compiling} allow the definition of domain specific
languages (DSLs) as libraries on top of a host language, and to compile them to a target platform. The deep embedding
gives the opportunity to control the code generation scheme for a given abstraction and target platform.

This paper presents such a DSL allowing developers to write Web applications in a single language which code
fragments can be shared between client and server sides, and which is efficiently compiled to each side. More
precisely, we demonstrate the following features:

\begin{itemize}
 \item Type-directed ad-hoc polymorphism on client-side without runtime dynamic dispatch logic;
 \item Usage of monads without extra container object creation;
 \item Ability to define DOM fragments using a common language for server-side and client-side, but that generates
code using standard APIs on both server-side and client-side;
 \item An API for searching in the DOM, that exposes a single entry point but that generates code potentially using
more optimized native APIs.
\end{itemize}

The remainder of this paper is organized as follows. The next section introduces existing approaches for defining
cross-compiling languages. Section \ref{contribution} presents our contribution. Section \ref{validation} evaluates
our contribution. Section \ref{discussion} concludes.

\section{Related Work}

\subsection{Fat Languages}

\subsection{Thin Languages}

\subsection{Deeply Embedded Languages}

Lightweight Modular Staging~\cite{Rompf12_LMSThesis} is a framework for defining deeply embedded DSLs in Scala. It
has been used to define high-performance DSLs for parallel computing~\cite{Brown11_Parallel} and can be used to
generate JavaScript code~\cite{Kossakowski12_JsDESL}.

\section{High-Level Abstractions Generating Efficient (and Heterogeneous) Code}
\label{contribution}

\subsection{Ad-Hoc Polymorphism}

\subsection{Monads Sequencing}

\subsection{DOM Fragments}

\subsection{Selectors}

\section{Implementation?}

\section{Evaluation}
\label{validation}

\subsection{Real World Application}

Chooze.

\subsection{Several Implementations}

\subsubsection{Vanilla JavaScript}

\subsubsection{jQuery}

\subsubsection{GWT}

\subsubsection{SharpKit}

\subsubsection{Js-Scala}

\subsection{Benchmarks, Code Metrics}

\section{Conclusion, Future Work}
\label{discussion}

%\appendix
%\section{Appendix Title}
%
%This is the text of the appendix, if you need one.
%
\acks

Acknowledgments, if needed.

\bibliographystyle{abbrvnat}
\bibliography{biblio}
%\begin{thebibliography}{}
%\softraggedright
%
%\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
%P. Q. Smith, and X. Y. Jones. ...reference text...
%
%\end{thebibliography}
%
\end{document}
