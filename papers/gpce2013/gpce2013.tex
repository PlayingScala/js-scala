\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[unicode=true,hidelinks]{hyperref}
\usepackage{graphicx}

\input{macros}

\newcommand{\ie}{\emph{i.e.}}
\newcommand{\eg}{\emph{e.g.}}
\newcommand{\cf}{\emph{cf.~}}
\newcommand{\etal}{\emph{et al.~}}
\newcommand{\etc}{\emph{etc.}}
\newcommand{\aka}{\emph{a.k.a.}}


\begin{document}

\conferenceinfo{GPCE '13}{October 27--28, 2013, Indianapolis, Indiana, USA} 
\copyrightyear{2013}
\copyrightdata{[to be supplied]} 

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{How to build an homogeneous language for heterogeneous platforms}
\subtitle{You don’t have to trade abstraction for control}

\authorinfo{Julien Richard-Foy\and Olivier Barais\and Jean-Marc Jézéquel}
           {IRISA, Université de Rennes 1}
           {\{first\}.\{last\}@irisa.fr}

\maketitle

\begin{abstract}
Writing large Web applications is known to be difficult. One challenge comes from the fact that the application's
logic is scattered into heterogeneous clients and servers, making it difficult to share code between both sides or to
move code from one side to the other. Another challenge is performance: while Web applications rely on ever more
code on the client-side, they may run on smart phones with little hardware capabilities. These two challenges raise
the following problem: how to benefit from high-level languages and libraries making code complexity easier to manage
and abstracting over the clients and servers differences without trading this engineering comfort for performance?
This article presents high-level abstractions defined as deep embedded DSLs in Scala, that can (1) generate efficient
code leveraging the target platform characteristics, (2) be shared between client and server code. Our DSLs have a
performance / expressiveness ratio about two times higher than other approaches.
\end{abstract}

\category{D.3.3}{Programming Languages}{Language Constructs and Features}

\terms Languages, Software Engineering

\keywords Heterogeneous Code Generation, Domain-specific languages

\section{Introduction}

Web applications are attractive because they require no installation or deployment steps on clients and enable large
scale collaborative experiences. However, writing large Web applications is known to be
difficult~\cite{Mikkonen08_SpaghettiJs,Preciado05_RIAMethodologyNecessity}. One challenge comes from the fact
that the business logic is scattered into heterogeneous client-side and server-side
environments~\cite{Echeverria09_RIA,Kuuskeri09_PartitioningClientServer}. This gives less flexibility in the
engineering process and requires a higher maintenance effort: if a piece of logic is implemented on client-side and
finally needs to be implemented on server-side instead, the code can not be reused and the feature needs to be
completely rewritten (and \emph{vice versa}). Even worse, logic parts that run on both client-side and server-side
need to be duplicated. For instance, HTML fragments may be built from the server-side when a page is requested by a
client, but they may also be built from the client-side to perform an incremental update subsequent to an user
action. How could developers write HTML fragment definitions once and render them on both client-side and
server-side?

The more interactive the application is, the more logic needs to be duplicated between the server-side
and the client-side, and the higher is the amount of client-side code. Developers use libraries and frameworks to get
high-level abstractions on client-side, making their code easier to reason about and to maintain, but also making
their code run less efficiently (abstraction penalty).

Using the same programming language on both server-side and client-side could improve the software engineering
process by enabling code reuse between both sides. Incidentally, the JavaScript language -- which is currently the
most supported the action language on Web clients -- can be used on server-side, and an increasing number of
programming languages or compiler back-ends can generate JavaScript code (\eg Java/GWT~\cite{Chaganti07_GWT},
SharpKit\footnote{\href{http://sharpkit.net}{http://sharpkit.net}}, Dart~\cite{Griffith11_Dart},
Kotlin\footnote{\href{http://kotlin.jetbrains.org/}{http://kotlin.jetbrains.org/}},
ClojureScript~\cite{McGranaghan11_ClojureScript}, Fay\footnote{\href{http://fay-lang.org/}{http://fay-lang.org/}},
Haxe~\cite{Cannasse08_HaXe} or Opa\footnote{\href{http://opalang.org/}{http://opalang.org/}}).

However, using the same programming language is not enough because the client and server programming environments
are not the same. For instance, DOM fragments can be defined on client-side using the standard DOM API, but this
API does not exist on server-side. How to define a common vocabulary for such concepts? And how to make the
executable code leverage the native APIs, when possible, for performance reasons?

Performance is a primary concern in Web applications, because they are expected to run on a broad range of devices,
from the powerful desktop personal computer to the less powerful smart phone. “Every 100~ms delay costs 1\% of
sales”, said Amazon in 2006.

Generating efficient code for heterogeneous platforms is hard to achieve in an extensible way: the translation of
common abstractions like collections into their native counterpart (JavaScript arrays on client-side and standard
library's collections on server-side) may be hard coded in the compiler, but that would not scale to handle all the
abstractions a complete application may use (\eg HTML fragment definitions, form validation rules, or even some
business data type that may be represented differently for performance reasons).

On one hand, for engineering reasons, developers want to write Web applications using a single high-level language,
abstracting over the target platforms differences. But on the other hand, for performance reasons, they want to keep
control on the way their code is compiled to each target platform. How to solve this dilemma?

Compiled domain specific embedded languages~\cite{Elliott2003_Compiling} allow the definition of domain specific
languages (DSLs) as libraries on top of a host language, and to compile them to a target platform. The deep embedding
gives the opportunity to control the code generation scheme for a given abstraction and target platform.

\texttt{js-scala} is such a compiled embedded DSL defined in Scala that generates JavaScript code, making it possible
to write the client-side code of Web applications using JavaScript~\cite{Kossakowski12_JsDESL}. This paper
enriches \texttt{js-scala} in order to solve the problem described above. We use staging~\cite{Jorring1986_Staging}
to:

\begin{itemize}
 \item generate efficient code for typical abstractions used in Web programming;
 \item generate specialized code for both client and server sides for shared abstractions.
\end{itemize}

Though the code written in \texttt{js-scala} is high-level and can be shared between clients and
servers, it has the same runtime performances as hand-tune low-level JavaScript code. We observed a performance /
expressiveness ratio two times higher than using other approaches.

The remainder of this paper is organized as follows. The next section introduces existing approaches for defining
cross-compiling languages. Sections \ref{contribution} and \ref{contribution-shared} present our contribution.
Section \ref{implementation} gives implementation details. Section \ref{validation} evaluates the contribution.
Section \ref{discussion} concludes.

\section{Background}

This section presents different approaches for defining cross-platform programming languages.

\begin{figure}
\begin{center}
\includegraphics[width=6cm]{langs.pdf}
\end{center}
\caption{Language engineering processes}
\label{langs}
\end{figure}

\paragraph{Fat Languages}

The first approach for defining a cross-platform language consists in hard-coding, in the compiler, the
code generation scheme of each language feature to each target platform. Figure \ref{langs} (a) depicts this
process. In order to support a feature related to a specific domain, the whole compiler pipeline (parser, code
generator, \etc) may have to be adapted. This approach gives \emph{fat} languages because a lot of concepts are
defined at the language level: general programming concepts such as naming, functions, classes, and more specific
concepts such as HTML fragment definition. Examples of such languages are Links~\cite{Cooper07_Links}, Opa and
Dart~\cite{Griffith11_Dart}. These languages are difficult to extend because each concept is defined in the compiler,
and modifying a compiler requires a high effort. Furthermore, these languages also require to support common
programming abstraction and composition mechanisms, as general purpose languages do. So they usually try to re-invent
the features of general purpose languages. We argue that this approach for defining programming languages is
difficult to scale: for every problem you have to rewrite a full-featured programming language before addressing the
concepts specific to the problem domain.

\paragraph{Domain Specific Languages}

Another approach consists in defining several small independent languages, each one focusing on concerns specific to
a given problem domain, and then to combine all the source artifacts written with these language into one executable
program (ref), as shown in figure~\ref{langs} (b). Defining such a language requires a minimal effort compared to the
previous approach. On the other hand, it is difficult to have interoperability between different DSLs (ref).
(add refs to DSL-based approaches to define Web programming environments)

\paragraph{Thin Languages}

Alternatively, one can define concepts relative to a specific domain as libraries on top of a thin general purpose
language (this is also referred to as \emph{embedded} domain specific languages). Figure \ref{langs} (c) depicts this
approach. The general purpose language is used as a host language and does not need to be modified if a new concept
is introduced, because concepts are defined as pure libraries. However, this approach gives no opportunity to
translate a concept efficiently according to the target platform characteristics. Examples of languages following
this approach are Java/GWT, Kotlin, HaXe and SharpKit.

\paragraph{Deeply Embedded Languages}

The last approach, shown in figure \ref{langs} (d), can be seen as a middle-ground between the two previous
approaches: DSLs are embedded in a host language but use a code generation process. (benefits and limitations of
this approach)

Lightweight Modular Staging~\cite{Rompf12_LMSThesis} is a framework for defining deeply embedded DSLs in Scala. It
has been used to define high-performance DSLs for parallel computing~\cite{Brown11_Parallel} and can be used to
generate JavaScript code~\cite{Kossakowski12_JsDESL}.

\section{High-Level Abstractions for Client-Side Code}
\label{contribution}

\subsection{Selectors}

In a Web application, the user interface is defined by a HTML document that can be updated by the JavaScript code.
A typical operation consists in searching some “interesting” element in the document, in order to extract its
content, replace it or listen to user events triggered on it. The standard API provides several functions to search
elements in a HTML document according to their name or attribute values. Figure~\ref{selectors-api} summarizes the
available functions and their differences.

\begin{figure}
\begin{center}
\begin{tabular}{| l | p{3cm} |}
\hline
Function & Description \\
\hline
\code{querySelector(s)} & First element matching the CSS selector \code{s} \\
\hline
\code{getElementById(i)} & Element which attribute \code{id} equals to \code{i} \\
\hline
\code{querySelectorAll(s)} & All elements matching the CSS selector \code{s} \\
\hline
\code{getElementsByTagName(n)} & All elements of type \code{n} \\
\hline
\code{getElementsByClassName(c)} & All elements which \code{class} attribute contains \code{c} \\
\hline
\end{tabular}
\end{center}
\caption{Standard selectors API}
\label{selectors-api}
\end{figure}

The \code{querySelector} and \code{querySelectorAll} are the most general functions, the others handle special
cases. For the developer it is not convenient to have to master several functions performing similar tasks. In fact,
most JavaScript developers use the jQuery
library~\cite{Bibeault08_jQuery}\footnote{According to the following document:
\href{http://trends.builtwith.com/javascript}{ http://trends.builtwith.com/javascript}, jQuery is used by more than
40\% of the top million sites} that provides only one function to search for elements.
Listings \ref{vanilla-selectors} and \ref{jquery-selectors} show two equivalent JavaScript programs, the first one
using the native APIs and the second one using jQuery.

\begin{figure}
\begin{lstlisting}[language=JavaScript,label=vanilla-selectors,caption=Selectors in plain JavaScript]
function getWords() {
  var form = document.getElementById('add-user');
  var sections =
    form.getElementsByTagName('fieldset');
  var results = [];
  for (var i = 0 ; i < sections.length ; i++) {
    var words = sections[i]
      .getElementsByClassName('word');
    results[i] = words;
  }
  return results
}
\end{lstlisting}
\end{figure}

\begin{figure}
\begin{lstlisting}[language=JavaScript,label=jquery-selectors,caption=Selectors in jQuery]
function getWords() {
  var form = $('#add-user');
  var sections = $('fieldset', form);
  return sections.map(function () {
    return $('.word', this)
  })
}
\end{lstlisting}
\end{figure}

jQuery provides an API that is simpler to master because it has less functions, but by doing so it can not benefit
from the performance of the browser’s implementation of specialized search functions (\code{getElementById},
\code{getElementsByTagName} and \code{getElementsByClassName}).

\begin{figure}
\begin{lstlisting}[label=js-scala-selectors,caption=Selectors in js-scala]
def getWords() = {
  val form = document.find("#add-user")
  val sections = form.findAll("fieldset")
  sections map (_.findAll(".word"))
}
\end{lstlisting}
\end{figure}

Listing~\ref{js-scala-selectors} shows how to implement listing~\ref{jquery-selectors} using js-scala. We provide two
functions for searching elements: \code{find} to find the first element matching a selector and \code{findAll} to
find all the matching elements. During staging these functions analyze the selector that is passed as parameter and,
when possible, produce code using the specialized API, otherwise they produce code using \code{querySelector} and
\code{querySelectorAll}. Thanks to this optimizations, listing~\ref{js-scala-selectors} generates a JavaScript
program identical to listing~\ref{vanilla-selectors}. Writing the program with js-scala instead of using a JavaScript
library such as jQuery is interesting because the abstraction for searching elements exist only in the initial
program source code, not in the final JavaScript program. It gives two advantages: (1) the execution of the final
program is more performant because of the use of specialized APIs, (2) the final program’s size is smaller because it
does not need to include jQuery.

\subsection{Monads Sequencing}

As another illustration of the staging mechanism, we present a simple DSL to handle null references. This DSL
provides an abstraction at the stage-level that is removed by optimization during the code generation.

Null references are a known source of problems in programming languages~\cite{Hoare09_Null,Nanda09_Null}. For
example, consider listing \ref{null-unsafe} finding a particular widget in the page and then a particular
button in the widget. The native \code{querySelector} method returns \code{null} if no node matched the given
selector in the document. If we run this code in a page where the widget is not present, it will throw an error
and stop further JavaScript execution. Listing \ref{null-defensive} shows defensive code to handle \code{null}
cases, but it leads to very cumbersome code.


\begin{figure}
\begin{lstlisting}[language=JavaScript,label=null-unsafe,caption=Unsafe code]
var loginWidget =
  document.querySelector("div.login");
var loginButton =
  loginWidget.querySelector("button.submit");
loginButton.addEventListener("click", handler);
\end{lstlisting}
\end{figure}


\begin{figure}
\begin{lstlisting}[language=JavaScript,label=null-defensive,caption=Defensive programming to handle null references]
var loginWidget =
  document.querySelector("div.login");
if (loginWidget !== null) {
  var loginButton =
    loginWidget.querySelector("button.submit");
  if (loginButton !== null) {
    loginButton.
      addEventListener("click", handler);
  }
}
\end{lstlisting}
\end{figure}

We want to define a DSL that has both the safety and performance of listing \ref{null-defensive} but the
expressiveness of listing \ref{null-unsafe}. We can get safety by wrapping potentially null values of type
\code{Rep[A]} in a container of type \code{Rep[Option[A]]} requiring explicit dereferencing, we can get
expressiveness by using the Scala \code{for} notation for dereferencing, and finally we can get performance by
generating code that does not actually wraps values in a container but instead checks if they are \code{null} or not
when dereferenced. The wrapping container exists only at the stage-level and is removed during the code generation.
Listing \ref{null-js-scala} shows how to write the same program using our DSL (implementation details are
given in section \ref{implementation}). The evaluation of this listing produces a graph of statements from which
JavaScript code equivalent to listing \ref{null-defensive} is generated.

\begin{figure}
\begin{lstlisting}[label=null-js-scala,caption=Handling null references in js-scala]
for {
  loginWidget <- document.find("div.login")
  loginButton <- loginWidget.find("submit.button")
} loginButton.on(Click) { e => ... }
\end{lstlisting}
\end{figure}


\section{High-Level Abstractions Shared on Clients and Servers}
\label{contribution-shared}

\begin{figure}
\begin{lstlisting}[language=JavaScript,caption=JavaScript DOM API,label=dom-api]
var articleUi = function (article) {
  var div = document.createElement('div');
  div.setAttribute('class', 'article');
  var span = document.createElement('span');
  var name =
    document.createTextNode(article.name + ': ');
  span.appendChild(name);
  div.appendChild(span);
  var strong = document.createElement('strong');
  var price = document.createTextNode(article.price);
  strong.appendChild(price);
  div.appendChild(strong);
  return div
};
\end{lstlisting}
\end{figure}

\begin{figure}
\begin{lstlisting}[language=HTML,caption=HTML,label=html]
<div class=article>
  <span>French wine: </span>
  <strong>10</strong>
</div>
\end{lstlisting}
\end{figure}

In this section we show how we can define a template engine as an embedded DSL with minimal effort. This template
engine is statically typed and able to insert dynamic content in a safe way. It provides a powerful expression
language, requires no extra compilation step and can be used on both client-side and server-side.

Because the template engine is defined as en embedded DSL, we can reuse Scala’s constructs:

\begin{itemize}
\item a function taking some parameters and returning a DOM fragment directly models a template taking parameters and
returning a DOM fragment~;
\item the type system type-checks template definitions and template calls~;
\item the Scala language itself is the expression language~;
\item compiling a template is the same as compiling user code.
\end{itemize}

So the only remaining work consists in defining the DSL vocabulary to define DOM nodes. We provide a \code{el}
function to define a tag and any \code{String} value is considered to be a text node.

\begin{figure}
\begin{lstlisting}[label=forest,caption=DOM definition DSL]
def articleUi(article: Rep[Article]) =
    el('div, 'class -> 'article)(
        el('span)(article.name + ": "),
        el('strong)(article.price)
    )
\end{lstlisting}
\end{figure}

Listing \ref{forest} uses our DSL and generates a code equivalent to listing \ref{dom-api}. The readability has
been highly improved: nesting tags is just like nesting code blocks, HTML entities are
automatically escaped in text nodes, developers have the full computational power of Scala to inject dynamic data and
DOM fragments definitions are written using functions so they compose just as functions compose. These benefits come
with no performance loss because the DSL generates code building DOM fragments by using the native JavaScript API.

Our DSL is equivalent to a template engine with Scala as the expression language. Making it usable on both server and
client sides was surprisingly as simple as defining another code generator for the DSL, producing Scala code.

For instance, the template written in listing \ref{forest} produces the following Scala code usable on
server-side:

\begin{lstlisting}
def articleUi(article: Article) = {
  val x0 = <span>{ article.name + ": " }</span>
  val x1 = <strong>{ article.price }</strong>
  val x2 =
    <div class="article">
      {List(x0, x1)}
    </div>
  x2
}
\end{lstlisting}

We are able to tackle the code sharing issues described in the introduction (more details?) because of the embdedded
nature of our DSLs: dynamic content of templates is written using embedded DSLs too, so their translation into
JavaScript and Scala is managed by their respective code generators.

% \subsection{Ad-Hoc Polymorphism}
% 
% Because of the dynamically typed nature of JavaScript, when calling a function there is no proper way to select a
% specialized implementation according to the function’s parameters types. JavaScript is only able to dispatch
% according to a method receiver prototype, \eg{} if one writes \code{foo.bar()} the JavaScript runtime will look into
% the prototype of the \code{foo} object for a property named \code{bar} and will call it. So, the only way to achieve
% \emph{ad hoc} polymorphism on JavaScript objects consists in defining the polymorphic function on the prototypes of
% the objects. However, modifying existing object prototypes is considered bad
% practice~\cite{Zakas12_MaintainableJs}. Another way could consist in manually coding the dispatch logic, by
% registering supported data types at the beginning of the program execution, as described in section 2.4.3
% of~\cite{Abelson83_SICP}, but this solution is painful for developers and incurs a performance overhead.
% 
% We propose to achieve \emph{ad hoc} polymorphism using
% typeclasses~\cite{Wadler89_AdhocPolymorphism,Odersky06_Typeclasses,Oliveira10_Typeclasses} so that it supports
% retroactive extension without modifying objects prototypes. The dispatch logic is type-directed and performed by the
% compiler, so there is no runtime overhead.
% 
% \begin{figure}
% \begin{lstlisting}[label=polymorphism,caption=Ad hoc polymorphism using typeclasses]
% // Interface
% case class Show[A](show: Rep[A => Node])
% 
% // Polymorphic function
% def listWidget[A](items: Rep[List[A]])
%       (implicit A: Show[A]): Rep[Node] =
%   el("ul")(
%     for (item <- items) yield {
%       el("li")(A.show(item))
%     }
%   )
% 
% // Type `User`
% type User = Record {
%   val name: String
%   val age: Int
% }
% // Implementation of Show for a User
% implicit val showUser = Show[User] { user =>
%   el("span", "class"->"user")(
%     user.name + "(" + user.age + " years)"
%   )
% }
% 
% // Main program
% def main(users: Rep[List[User]]) = {
%   document.body.append(listWidget(users))
% }
% \end{lstlisting}
% \end{figure}
% 
% Listing \ref{polymorphism} demonstrates how to define a polymorphic \code{listWidget} function that returns a DOM
% tree containing the representation of a list of items. The \code{Show[A]} typeclass defines how to produce a DOM tree
% for a value of type \code{A}. It is used by the \code{listWidget} function to get the DOM fragments of the list
% items. The listing shows how to reuse the same \code{listWidget} function to show a list of users and a list of
% articles.

\section{Implementation}
\label{implementation}

\footnote{The code is available at \href{http://github.com/js-scala}{http://github.com/js-scala}}

\subsection{Selectors}

\begin{figure}
\begin{lstlisting}[label=selector-impl,caption=Selectors optimization]
def find(receiver: Exp[Selector],
         selector: Exp[String]) =
  getConstIdentifier(selector) match {
    case Some(id) if receiver == document =>
      DocumentGetElementById(Const(id))
    case _ =>
      SelectorFind(receiver, selector)
  }
\end{lstlisting}
\end{figure}

Listing \ref{selector-impl}

\subsection{Null references}

Code generation consists in traversing the statement nodes produced by the program evaluation according to their
dependencies and to emit the code corresponding to each statement. LMS already sorts the statements graph so DSL
authors just need to say how to emit code for each statement node of their DSL. Listing \ref{option-codegen} shows
such a code generator for the \code{null} reference handling DSL. The \code{emitNode} method handles
\code{OptionIsEmpty} and \code{OptionForeach} nodes. In the case of the \code{OptionIsEmpty} node, it simply
generates an expression testing if the value is \code{null}, in the case of the \code{OptionForeach} node, it wraps
the code block dereferencing the value within a \code{if} checking that the value is not \code{null}.

\begin{figure}
\begin{lstlisting}[caption=Null reference handling DSL code generator,label=option-codegen]
trait JSGenOptionOps extends JSGenEffect {
  val IR: OptionOpsExp
  import IR._
  override def emitNode(sym: Sym[Any], rhs: Def[Any]) =
    rhs match {
      case OptionIsEmpty(o) =>
        emitValDef(sym, q" $o === null")
      case OptionForeach(o, a, b) =>
        stream.println(q"if ($o !== null) {")
        emitValDef(a, quote(o))
        emitBlock(b)
        stream.println("}")
      case _ =>
        super.emitNode(sym, rhs)
    }
}
\end{lstlisting}
\end{figure}

\subsection{DOM Fragments}

\section{Evaluation}
\label{validation}

We implemented several applications using js-scala. We also have written several implementations of a complete
application, using different approaches to write the client and server sides, and compared the amount of code
written, the runtime performances and the ability to modularize the code and to maintain it.

\subsection{Real World Application}

Chooze~\footnote{\href{http://chooze.herokuapp.com}{http://chooze.herokuapp.com}} is an existing complete
application for making polls. It allows users to create a poll, define the choice alternatives, share the poll, vote
and look at the results. It contains JavaScript code to handle the dynamic behavior of the application:
double-posting prevention, dynamic form update and rich interaction with the document.

The application was initially written using jQuery. We rewrote it using several technologies for the client-side
part: plain JavaScript (without third-party library), js-scala, GWT and HaXe.

\paragraph*{Vanilla JavaScript} Low-level code.

\paragraph*{jQuery} High-level code.

\paragraph*{js-scala} High-level code. HTML fragment definition reused between server and client sides.

\paragraph*{HaXe} Low-level code.

\paragraph*{GWT} High-level code?

\subsection{Benchmarks, Code Metrics}

Our goal is to evalute the level of abstraction provided by each solution and their performances. We took the
number of lines of code as a measure of the level of abstraction. We also measured the size of the data sent to the
client-side. We also measured the ability to share code between client and server sides.

Rather than doing a micro-benchmark focusing on just one abstraction, we performed a global benchmark that is more
likely to reflect the real performances of the application: we simulated user actions on a Web page (2000 clicks on
buttons, triggering a dynamic update of the page and involving the use of the Option monad, the selectors API and
the HTML fragment definition API) and measured the time it took complete them. We only measured the execution time of
client-side code execution. The tests were run on a DELL Latitude E6430 laptop with 8 GB of RAM, on the Google
Chrome v27 Web browser. Figure \ref{benchmark} shows the benchmark results.

\begin{figure}
\centering
\includegraphics[width=8cm]{chooze.png}
\caption{Benchmarks on a real application}
\label{benchmark}
\end{figure}


\section{Conclusion}
\label{discussion}

We implemented a high-level language abstracting over client and server heterogeneity but producing efficient code.

%\appendix
%\section{Appendix Title}
%
%This is the text of the appendix, if you need one.
%
\acks

Acknowledgments, if needed.

\bibliographystyle{abbrvnat}
\bibliography{biblio}
%\begin{thebibliography}{}
%\softraggedright
%
%\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
%P. Q. Smith, and X. Y. Jones. ...reference text...
%
%\end{thebibliography}
%
\end{document}
