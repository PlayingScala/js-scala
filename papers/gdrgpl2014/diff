1c1
< \documentclass{sigplanconf}
---
> \documentclass{llncs}
92,93c92,93
< \conferenceinfo{GPCE~'13}{October 27--28, 2013, Indianapolis, Indiana, USA} 
< \copyrightyear{2013} \copyrightdata{978-1-4503-2373-4/13/10} \doi{2517208.2517227}
---
> %\conferenceinfo{GPCE~'13}{October 27--28, 2013, Indianapolis, Indiana, USA} 
> %\copyrightyear{2013} \copyrightdata{978-1-4503-2373-4/13/10} \doi{2517208.2517227}
101,103c101,104
< \authorinfo{Julien Richard-Foy\and Olivier Barais\and Jean-Marc Jézéquel}
<            {IRISA, Université de Rennes 1}
<            {\{first\}.\{last\}@irisa.fr}
---
> \author{Richard-Foy\and Olivier Barais\and Jean-Marc Jézéquel}
>           
> \institute{ IRISA, Université de Rennes 1
>            {\email{\{first\}.\{last\}@irisa.fr}}}
123c124
< \category{D.3.3}{Programming Languages}{Language Constructs and Features}
---
> %\category{D.3.3}{Programming Languages}{Language Constructs and Features}
184,185c185
< abstractions in compiled domain-specific embedded languages (DSELs)~\cite{Hudak96_DSEL,
< Elliott2003_Compiling}. Compiled DSELs allow the definition of domain-specific languages (DSLs) as
---
> abstractions in compiled domain-specific embedded languages (DSELs)~\cite{Hudak96_DSEL,Elliott2003_Compiling}. Compiled DSELs allow the definition of domain-specific languages (DSLs) as
290c290
< Lightweight Modular Staging~\cite{Rompf12_LMSThesis, Rompf12_LMS} (LMS) is a framework for defining
---
> Lightweight Modular Staging~\cite{Rompf12_LMSThesis,Rompf12_LMS} (LMS) is a framework for defining
311a312,462
> \subsection{LMS technical overview}
> 
> In LMS, a DSL is split into two parts, its
> interface and its implementation. Both parts can be assembled from
> components in the form of Scala traits. DSL programs are written in
> terms of the DSL interface only, without knowledge of the
> implementation.
> 
> Part of each DSL interface is an abstract type constructor
> \code{Rep[_]} that is used to wrap types in the DSL programs. The DSL
> implementation provides a concrete instantiation of \code{Rep} as IR
> nodes. When the DSL program is staged, it produces an intermediate
> representation (IR), from which the final code can be generated. In
> the DSL program, wrapped types such as \code{Rep[Int]} represent
> staged computations while expressions of plain unwrapped types
> (\code{Int}, \code{Bool}, etc.) are evaluated at staging time as
> in~\cite{finally-tagless,polymorphic-embedding}.
> 
> Consider the difference between these two programs:
> \begin{lstlisting}
> def prog1(b: Bool, x: Rep[Int]) = if (b) x else x+1
> def prog2(b: Rep[Bool], x: Rep[Int]) = if (b) x else x+1
> \end{lstlisting}
> 
> The only difference in these two programs is the type of the parameter
> \code{b}, illustrating that staging is purely type-driven with no
> syntactic overhead as the body of the programs are identical.
> 
> In \code{prog1}, \code{b} is a simple boolean, so it must be provided
> at staging time, and the \code{if} is evaluated at staging time. For
> example, \code{prog1(true, x)} evaluates to \code{x}. In \code{prog2},
> \code{b} is a staged value, representing a computation which yields a
> boolean. So \code{prog2(b, x)} evaluates to an IR node for the \code{if}:
> {\tt\small If(b, x, Plus(x, Const(1)))}.
> 
> For \code{prog2}, notice that the \code{if} got transformed into an IR
> node. To achieve this, LMS uses
> Scala-Virtualized~\cite{scala-virtualized}, a suite of minimal
> extensions to the regular Scala compiler, in which control
> structures such as \code{if} can be reified into method calls, so that
> alternative implementations can be provided. In our case, we provide an
> implementation of \code{if} that constructs an IR node instead of
> acting as a conditional. In addition, the \code{+} operation is
> overloaded to act on both staged and unstaged expressions. This is
> achieved by an implicit conversion from \code{Rep[Int]} to a class
> \code{IntOps}, which defines a \code{+} method that creates an IR node
> \code{Plus} when executed. Both of \code{Plus}'s arguments must be
> staged. We use an implicit conversion to stage constants when needed
> by creating a \code{Const} IR node.
> 
> \subsection{Example: a DSL program and its generated JavaScript code}
> 
> The following DSL snippet creates an array representing a table of
> multiplications:
> \begin{lstlisting}
> def test(n: Rep[Int]): Rep[Array[Int]] =
>   for (i <- range(0, n); j <- range(0, n)) yield i*j
> \end{lstlisting}
> 
> Here is the JavaScript code generated for this snippet:
> \begin{lstlisting}[language=JavaScript]
> function test(x0) {
>   var x6 = []
>   for(var x1=0;x1<x0;x1++){
>     var x4 = []
>     for(var x2=0;x2<x0;x2++){
>       var x3 = x1 * x2
>       x4[x2]=x3
>     }
>     x6.splice.apply(x6, [x6.length,0].concat(x4))
>   }
>   return x6
> }
> \end{lstlisting}
> 
> The generated code resembles single-assignment form. The nested
> \code{for}-loop is desugared into a \code{flatMap} which generates the
> nested \code{for}-loop and the \code{splice} pattern concatenating the
> inner \code{x4} arrays into one \code{x6} array in the JavaScript
> code.\footnote{Obviously, the generated code can be optimized further.}
> 
> \subsection{Walkthrough: defining a DSL component}\label{sec:defineDslComponent}
> 
> To conclude the introduction to LMS, we show how to add a component
> for logging in a DSL, generating JavaScript code which calls
> \code{console.log}.
> 
> We start by defining the interface:
> \begin{lstlisting}
> trait Debug extends Base {
>   def log(msg: Rep[String]): Rep[Unit]
> }
> \end{lstlisting}
> 
> The \code{Base} trait is part of the core LMS framework and provides
> the abstract type constructor \code{Rep}.
> 
> Now, we define the implementation:
> \begin{lstlisting}
> trait DebugExp extends Debug with EffectExp {
>   case class Log(msg: Exp[String]) extends Def[Unit]
>   def log(msg: Exp[String]): Exp[Unit] = reflectEffect(Log(msg))
> }
> \end{lstlisting}
> 
> The \code{EffectExp} trait is part of the core LMS framework. It
> inherits from \code{BaseExp} which instantiates \code{Rep} as
> \code{Exp}. \code{Exp} represents an IR via two subclasses:
> \code{Const} for constants and \code{Sym} for named values defining a
> \code{Def}. \code{Def} is the base class for all IR nodes. In our
> \code{DebugExp} trait, we extend \code{Def} to support a new IR node:
> \code{Log}.
> 
> IR nodes are defined as \code{Def}s but they are never referenced
> explicitly as such. Instead each \code{Def} has a corresponding symbol
> (an instance of \code{Sym}). IR nodes refer to each other using their
> symbols. This is why, in the code shown, the \code{msg} parameter is
> of type \code{Exp} (not \code{Def}). The method \code{log} 
> returns an \code{Exp}. Calling \code{reflectEffect} is what creates
> this symbol from the \code{Def}.
> 
> In general, the framework provides an implicit conversion from
> \code{Def} to \code{Exp}, which performs common subexpression
> elimination by re-using the same symbol for identical definitions. We
> do not use the automatic conversion here, because \code{log} is a 
> side-effecting operation, and we do not want 
> to (re)move any such calls even if their message
> is the same.
> 
> The framework schedules the code generation from the graph of
> \code{Exp}s and their dependencies through \code{Def}s. It chooses
> which \code{Sym}/\code{Def} pairs to emit and in which order. To
> implement code generation to JavaScript for our logging IR node, we
> simply override \code{emitNode} to handle \code{Log}:
> \begin{lstlisting}
> trait JSGenDebug extends JSGenEffect {
>   val IR: DebugExp
>   import IR._
>   override def emitNode(sym: Sym[Any], rhs: Def[Any])(
>     implicit stream: PrintWriter) = rhs match {
>       case Log(s) => emitValDef(sym, "console.log(" + quote(s) + ")")
>       case _ => super.emitNode(sym, rhs)
>     }
> }
> \end{lstlisting}
> Notice that in order to compose nicely with other traits, the
> overridden method just handles the case it knows and delegates to
> other traits, via \code{super}, the emitting of nodes it doesn't know
> about.
> 
> 
323c474
< JavaScript code. A typical operation consists in searching some “interesting” element in the
---
> JavaScript code. A typical operation consists in searching some "interesting" element in the
915,1094c1066,1069
< \bibliographystyle{abbrvnat}
< \begin{thebibliography}{24}
< \providecommand{\natexlab}[1]{#1}
< \providecommand{\url}[1]{\texttt{#1}}
< \expandafter\ifx\csname urlstyle\endcsname\relax
<   \providecommand{\doi}[1]{doi: #1}\else
<   \providecommand{\doi}{doi: \begingroup \urlstyle{rm}\Url}\fi
< 
< \bibitem[Ashkenas(2011)]{Ashkenas2011_CoffeeScript}
< J.~Ashkenas.
< \newblock Coffeescript, 2011.
< 
< \bibitem[Bibeault and Kats(2008)]{Bibeault08_jQuery}
< B.~Bibeault and Y.~Kats.
< \newblock \emph{jQuery in Action}.
< \newblock Dreamtech Press, 2008.
< 
< \bibitem[Brown et~al.(2011)Brown, Sujeeth, Lee, Rompf, Chafi, Odersky, and
<   Olukotun]{Brown11_Parallel}
< K.~J. Brown, A.~K. Sujeeth, H.~J. Lee, T.~Rompf, H.~Chafi, M.~Odersky, and
<   K.~Olukotun.
< \newblock A heterogeneous parallel framework for domain-specific languages.
< \newblock In \emph{Parallel Architectures and Compilation Techniques (PACT),
<   2011 International Conference on}, pages 89--100. IEEE, 2011.
< 
< \bibitem[Cannasse(2008)]{Cannasse08_HaXe}
< N.~Cannasse.
< \newblock Using haxe.
< \newblock \emph{The Essential Guide to Open Source Flash Development}, pages
<   227--244, 2008.
< 
< \bibitem[Chaganti(2007)]{Chaganti07_GWT}
< P.~Chaganti.
< \newblock \emph{Google Web Toolkit: GWT Java Ajax Programming}.
< \newblock Packt Pub Limited, 2007.
< 
< \bibitem[Cooper et~al.(2007)Cooper, Lindley, Wadler, and
<   Yallop]{Cooper07_Links}
< E.~Cooper, S.~Lindley, P.~Wadler, and J.~Yallop.
< \newblock Links: Web programming without tiers.
< \newblock In \emph{Formal Methods for Components and Objects}, pages 266--296.
<   Springer, 2007.
< 
< \bibitem[Elliott et~al.(2003)Elliott, Finne, and
<   De~Moor]{Elliott2003_Compiling}
< C.~Elliott, S.~Finne, and O.~De~Moor.
< \newblock Compiling embedded languages.
< \newblock \emph{Journal of Functional Programming}, 13\penalty0 (3):\penalty0
<   455--481, 2003.
< 
< \bibitem[Griffith(2011)]{Griffith11_Dart}
< R.~Griffith.
< \newblock The dart programming language for non-programmers-overview.
< \newblock 2011.
< 
< \bibitem[Hoare(2009)]{Hoare09_Null}
< T.~Hoare.
< \newblock Null references: The billion dollar mistake.
< \newblock \emph{Presentation at QCon London}, 2009.
< 
< \bibitem[Huang et~al.(2010)Huang, Xu, Tiwana, Mao, Zhang, and
<   Bahl]{Huang10_Perf}
< J.~Huang, Q.~Xu, B.~Tiwana, Z.~M. Mao, M.~Zhang, and P.~Bahl.
< \newblock Anatomizing application performance differences on smartphones.
< \newblock In \emph{Proceedings of the 8th international conference on Mobile
<   systems, applications, and services}, pages 165--178. ACM, 2010.
< 
< \bibitem[Hudak(1996)]{Hudak96_DSEL}
< P.~Hudak.
< \newblock Building domain-specific embedded languages.
< \newblock \emph{ACM Computing Surveys}, 28, 1996.
< \newblock URL \url{http://dsel.ps}.
< 
< \bibitem[J{\o}rring and Scherlis(1986)]{Jorring1986_Staging}
< U.~J{\o}rring and W.~L. Scherlis.
< \newblock Compilers and staging transformations.
< \newblock In \emph{Proceedings of the 13th ACM SIGACT-SIGPLAN symposium on
<   Principles of programming languages}, pages 86--96. ACM, 1986.
< 
< \bibitem[Kossakowski et~al.(2012)Kossakowski, Amin, Rompf, and
<   Odersky]{Kossakowski12_JsDESL}
< G.~Kossakowski, N.~Amin, T.~Rompf, and M.~Odersky.
< \newblock Java{S}cript as an {E}mbedded {DSL}.
< \newblock In J.~Noble, editor, \emph{{ECOOP} 2012 -- {O}bject-{O}riented
<   {P}rogramming}, volume 7313 of \emph{Lecture Notes in Computer Science},
<   pages 409--434, Berlin, Heidelberg, 2012. Springer Berlin Heidelberg.
< \newblock \doi{10.1007/978-3-642-31057-7_19}.
< \newblock URL \url{https://github.com/js-scala/js-scala/}.
< 
< \bibitem[Kuuskeri and Mikkonen(2009)]{Kuuskeri09_PartitioningClientServer}
< J.~Kuuskeri and T.~Mikkonen.
< \newblock Partitioning web applications between the server and the client.
< \newblock In \emph{Proceedings of the 2009 ACM symposium on Applied Computing},
<   SAC '09, pages 647--652, New York, NY, USA, 2009. ACM.
< \newblock ISBN 978-1-60558-166-8.
< \newblock \doi{10.1145/1529282.1529416}.
< \newblock URL \url{http://doi.acm.org/10.1145/1529282.1529416}.
< 
< \bibitem[McGranaghan(2011)]{McGranaghan11_ClojureScript}
< M.~McGranaghan.
< \newblock Clojurescript: Functional programming for javascript platforms.
< \newblock \emph{Internet Computing, IEEE}, 15\penalty0 (6):\penalty0 97--102,
<   2011.
< 
< \bibitem[Mikkonen and Taivalsaari(2008)]{Mikkonen08_SpaghettiJs}
< T.~Mikkonen and A.~Taivalsaari.
< \newblock Web applications - spaghetti code for the 21st century.
< \newblock In \emph{Proceedings of the 2008 Sixth International Conference on
<   Software Engineering Research, Management and Applications}, pages 319--328,
<   Washington, DC, USA, 2008. IEEE Computer Society.
< \newblock ISBN 978-0-7695-3302-5.
< \newblock \doi{10.1109/SERA.2008.16}.
< \newblock URL \url{http://dl.acm.org/citation.cfm?id=1443226.1444030}.
< 
< \bibitem[Nanda and Sinha(2009)]{Nanda09_Null}
< M.~Nanda and S.~Sinha.
< \newblock Accurate interprocedural null-dereference analysis for java.
< \newblock In \emph{Software Engineering, 2009. ICSE 2009. IEEE 31st
<   International Conference on}, pages 133--143. IEEE, 2009.
< 
< \bibitem[Preciado et~al.(2005)Preciado, Trigueros, S{\'a}nchez-Figueroa, and
<   Comai]{Preciado05_RIAMethodologyNecessity}
< J.~C. Preciado, M.~L. Trigueros, F.~S{\'a}nchez-Figueroa, and S.~Comai.
< \newblock Necessity of methodologies to model rich internet applications.
< \newblock In \emph{WSE}, pages 7--13. IEEE Computer Society, 2005.
< \newblock ISBN 0-7695-2470-2.
< 
< \bibitem[Rodr{\'\i}guez-Echeverr{\'\i}a(2009)]{Echeverria09_RIA}
< R.~Rodr{\'\i}guez-Echeverr{\'\i}a.
< \newblock Ria: more than a nice face.
< \newblock In \emph{Proceedings of the Doctolral Consortium of the International
<   Conference on Web Engineering}, volume 484. CEUR-WS.org, 2009.
< 
< \bibitem[Rompf(2012)]{Rompf12_LMSThesis}
< T.~Rompf.
< \newblock \emph{Lightweight Modular Staging and Embedded Compilers: Abstraction
<   without Regret for High-Level High-Performance Programming}.
< \newblock PhD thesis, {\'E}COLE POLYTECHNIQUE F{\'E}D{\'E}RALE DE LAUSANNE,
<   2012.
< 
< %\vfill\eject
< 
< \bibitem[Rompf et~al.(2012)Rompf, Sujeeth, Amin, Brown, Jovanovic, Lee,
<   Jonnalagedda, Olukotun, and Odersky]{Rompf12_LMS}
< T.~Rompf, A.~Sujeeth, N.~Amin, K.~Brown, V.~Jovanovic, H.~Lee, M.~Jonnalagedda,
<   K.~Olukotun, and M.~Odersky.
< \newblock Optimizing {D}ata {S}tructures in {H}igh-{L}evel {P}rograms: {N}ew
<   {D}irections for {E}xtensible {C}ompilers based on {S}taging.
< \newblock Technical report, 2012.
< 
< \bibitem[Souders(2008)]{Souders08_Perf}
< S.~Souders.
< \newblock High-performance web sites.
< \newblock \emph{Communications of the ACM}, 51\penalty0 (12):\penalty0 36--41,
<   2008.
< 
< \bibitem[Van~Deursen et~al.(2000)Van~Deursen, Klint, and Visser]{Van00_DSL}
< A.~Van~Deursen, P.~Klint, and J.~Visser.
< \newblock Domain-specific languages: an annotated bibliography.
< \newblock \emph{ACM Sigplan Notices}, 35\penalty0 (6):\penalty0 26--36, 2000.
< 
< \bibitem[Visser(2007)]{Visser07}
< E.~Visser.
< \newblock {WebDSL}: {A} case study in domain-specific language engineering.
< \newblock In R.~Lämmel, J.~Visser, and J.~Saraiva, editors, \emph{Generative
<   and Transformational Techniques in Software Engineering II, International
<   Summer School, {GTTSE} 2007}, volume 5235 of \emph{Lecture Notes in Computer
<   Science}, pages 291--373, Braga, Portugal, 2007. Springer.
< \newblock ISBN 978-3-540-88642-6.
< \newblock \doi{http://dx.doi.org/10.1007/978-3-540-88643-3_7}.
< 
< \end{thebibliography}
< %\begin{thebibliography}{}
< %\softraggedright
< %
< %\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
< %P. Q. Smith, and X. Y. Jones. ...reference text...
< %
< %\end{thebibliography}
< %
---
> \bibliographystyle{splncs}
> %\bibliographystyle{plain}
> \bibliography{biblio}
> 
