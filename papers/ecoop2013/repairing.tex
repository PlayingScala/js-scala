\def\thelstlisting{}
\documentclass[american,english,runningheads]{llncs}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage[pdftex]{graphicx}
\usepackage[unicode=true,hidelinks]{hyperref}
\usepackage{times}
\usepackage{comment}
\setcounter{tocdepth}{2}

\clubpenalty=10000
\widowpenalty=10000
\tolerance=1000

\newcommand{\ie}{\emph{i.e.}}
\newcommand{\eg}{\emph{e.g.}}
\newcommand{\cf}{\emph{cf.~}}
\newcommand{\etal}{\emph{et al.~}}
\newcommand{\etc}{\emph{etc.}}
\newcommand{\aka}{\emph{a.k.a.}}

\newcommand{\noun}[1]{\textsc{#1}}

\newtheorem{mydef}{Definition}

\input{macros}


\begin{document}

\setcounter{lstlisting}{0}
\renewcommand{\thelstlisting}{\arabic{lstlisting}}

\title{Statically Typed Web Programming using Scala}

\author{Julien \noun{Richard-Foy}\textsuperscript{\textasteriskcentered}\textsuperscript{\textdaggerdbl} \and Olivier
\noun{Barais}\textsuperscript{\textasteriskcentered} \and Tiark \noun{Rompf}\textsuperscript{\textdagger} \and
Jean-Marc \noun{Jézéquel}\textsuperscript{\textasteriskcentered}}
\institute{\textsuperscript{\textasteriskcentered}IRISA, Université de Rennes 1, France:
\texttt{\{first\}.\{last\}@irisa.fr}\\
\textsuperscript{\textdaggerdbl}Zenexity, Paris, France: \texttt{jrf@zenexity.com}\\
\textsuperscript{\textdagger}EPFL, Lausanne, Switzerland: \texttt{tiark.rompf@epfl.ch}}

\authorrunning{Julien \noun{Richard-Foy} \etal{}}

\maketitle


\begin{abstract}
Rich Internet Applications rely on ever more code on the client-side, 
typically written in JavaScript, dealing
with DOM manipulation, event handling and asynchronous calls to the 
server. Beyond well documented JavaScript programming intrinsic issues,
the hard wired distribution of an application business logic across 
clients and servers hampers its flexibility and maintainability. This 
paper presents a Scala compiled
embedded DSL for Web programming trying to address these shortcomings. 
Close to JavaScript, it provides type-safe
and expressive abstractions for DOM manipulation, event handling and
asynchronous programming. Code written using the DSL can be compiled to both
server and client sides. Built on top of the Lightweight Modular Staging
framework, this DSL uses both type-level information and staging to  introduce
high-level abstractions that translate to efficient JavaScript and Scala 
code using native APIs.
\end{abstract}

{\bf Keywords:} Web, programming languages, embedded DSL, type-level programming, staging, Scala

\section{Introduction}

The Web is an appealing platform on which to write applications (\aka{} Rich Internet Applications, RIA) because it
makes them easy to deploy on clients and allows large scale innovative collaborative
experiences~\cite{Farrell07_RIA,Mikkonen08_SpaghettiJs}. RIAs are characterized by partial updates of the user
interface (as opposed to refreshing the whole page with the classic hyperlink navigation), so a large part of the
client-side code listens to user interface events (such as mouse clicks), triggers the appropriate action
asynchronously on the server using AJAX~\cite{Garrett05_Ajax} and updates the application’s state and the page content
with a new DOM fragment computed from the response data~\cite{Farrell07_RIA,Busch09_StateOfArtRIA}.

Writing large Web applications is known to be
challenging~\cite{Mikkonen08_SpaghettiJs,Preciado05_RIAMethodologyNecessity}, mainly because of the heterogeneous
nature of the client-side and server-side environments~\cite{Echeverria09_RIA,Kuuskeri09_PartitioningClientServer}:
writing distributed code requires its different parts to be consistent and leads to code duplication unless one uses
the same language in both sides, which, in the case of the Web, means using JavaScript to write the whole
application. However this language has several drawbacks making it hardly suitable for large code bases (\eg{} no
static typing, no module system, verbose syntax, \etc). Some other in-browser execution environments give the
opportunity to write the client-side code in another language that JavaScript, \eg{} Java
applets~\cite{Anuff96_JavaApplets}, Adobe Flash~\cite{Curtis00_Flash} and Microsoft
Silverlight\footnote{\href{http://www.microsoft.com/silverlight/}{http://www.microsoft.com/silverlight/}}. However
these technologies also have several drawbacks: they require an additional browser plugin to be installed (which may
not be available on all devices having a Web browser: for instance there is no way to execute Flash objects within an
Apple smart phone), the page content cannot naturally be referenced by search engines, and the content is not
structured in URLs that users can bookmark or share.

An increasing number of initiatives attempt to allow developers to write the client-side code in a language different
than JavaScript but that can be compiled to JavaScript (\eg{} GWT~\cite{Chaganti07_GWT}, Dart~\cite{Griffith11_Dart},
TypeScript\footnote{\href{http://www.typescriptlang.org/}{http://www.typescriptlang.org/}}, Roy~\cite{McKenna_Roy}).
Some of these languages can also be compiled to another runtime environment usable on server-side (\eg{} GWT, Dart,
Kotlin\footnote{\href{http://kotlin.jetbrains.org/}{http://kotlin.jetbrains.org/}},
ClojureScript~\cite{McGranaghan11_ClojureScript}, Fay\footnote{\href{http://fay-lang.org/}{http://fay-lang.org/}},
Haxe~\cite{Cannasse08_HaXe} or Opa\footnote{\href{http://opalang.org/}{http://opalang.org/}}). These languages are
usually more suitable to write large applications either because they provide more constructs to build abstractions
(such as object orientation), or because they are statically typed, or because they add some useful concepts
that are missing in JavaScript (such as \emph{adhoc} polymorphism or namespaces). Moreover, their ability to compile
for both server and client sides usually allows developers to share some parts of code between server and client
sides for free. However this shared code is restricted to exclusively use language constructs: concepts provided by
external APIs can't be shared between server and client sides because the bindings with these environments are
different on the server and client sides.

In this paper we investigate further \emph{js-scala}, a path already introduced by Kossakowski \etal{}: defining
JavaScript as a compiled embedded DSL in Scala~\cite{Kossakowski12_JsDESL}. This approach is based on Lightweight
Modular Staging~\cite{Rompf12_LMSThesis}: a Scala program written using the embedded DSL evaluates to an intermediate
representation that can be further processed to perform domain specific optimizations and then to generate a
JavaScript program (for the client-side) and a Scala program (for the server-side). This approach has two main
advantages: (1) the embedding reduces the effort needed to define the language since we can reuse the Scala
infrastructure and tooling, and (2) staging gives more knowledge to the compiler about how a given abstraction
should be efficiently translated into the target environment. In other words any library-level abstraction can have
the efficiency of a language-level abstraction.

This previous work on js-scala showed how to write client-side code in Scala using the JavaScript embedded DSL and
how to share code between server-side and client-side. The authors also showed that the code was safer and more
convenient to write thanks to Scala's static typing and class system. Finally, they showed how to \emph{un-invert}
the control of callback-based asynchronous APIs by using continuations but they did not address other concerns of
RIAs development such as user interface events handling and DOM creation and manipulation.

Based on this work, this paper introduces several type-safe and expressive DSL constructs for RIAs development. This
DSL increases the expressivity of JavaScript native APIs with no runtime overhead and exposes them through statically
typed APIs. It makes asynchronous programming simpler by raising asynchronous computations to first-class citizens.
It leverages the Scala type system to bring type-directed language features such as \emph{ad hoc} polymorphism and
type coercion to the client-side. Finally, code written using the DSL can be compiled to both server and client
sides.

% This paper continues their work and presents and discusses the implementation of the following contributions:
% 
% \begin{itemize}
% 
% % JSDom, Forest
% \item We expose native JavaScript APIs for DOM manipulation and event handling as statically typed APIs while reducing their syntactic noise ;
% 
% % State monad, FutureOps, OptionOps
% \item We define a high-level abstraction to handle program's state changes and an abstraction turning asynchronous computations into first-class values. Then we show how to exploit staging to translate these abstractions into JavaScript with a minimal overhead ;
% 
% % NumericOps, Typeclasses
% \item We use Scala's advanced type-level constructs to elegantly express type coercion constraints on operands in arithmetic operations and to achieve \emph{adhoc} polymorphism with no overhead at all in the generated code ;
% 
% % Forest server-side, cross-browser incompatibilities
% \item Our code generation system is flexible enough to handle cross-browsers incompatibilities and, unlike other approaches, to allow the sharing of concepts between client-side and server-side even if these concepts are translated into code using external APIs.
% 
% \end{itemize}

The next section introduces a simple application example showing the main challenges of RIA development, section
\ref{solution} presents our DSL tackling these challenges, section \ref{validation} evaluates our solution, section
\ref{related} compares our solution to related works and section \ref{discussion} concludes.

%\section{Web programming challenges?}

\section{Background and Motivating Example}
\label{problem}

To illustrate the challenges of writing a RIA and the need for a DSL for writing them, we introduce a simple “mind
mapping” application and show how the client-side code would typically be written in JavaScript.

\subsection{Example Description}

In our application, a mind map is represented as a graph where ideas or concepts are represented by vertices, and the
relation between two ideas is represented by an edge. Users can visualize a mind map, zoom in and out and move it.
They can also add ideas and link them together. Figure \ref{mindmap} shows the visualization of a simple map
consisting of three ideas linked together, using our application.

\begin{figure}
 \caption{A simple mind map as visualized with our application}
 \centering
 \includegraphics[width=8cm]{mindmap.png}
 \label{mindmap}
\end{figure}

\subsection{Implementation in JavaScript}

\subsubsection{Event handling}

RIAs distinguish themselves from classic Web pages by a higher degree of interactivity. In our example we want to let users zoom
in and out a map using their mouse wheel. To implement this feature we need to attach an event handler for the
\code{mousewheel} event on the DOM element containing the map. The following listing shows how to attach such an
event handler using the native JavaScript API:

\begin{lstlisting}[language=JavaScript,label=event-js,caption=Native JavaScript API to handle events]
mapElement.addEventListener("mousewheel", function (e) {
  scale = Math.round(scale + e.wheelDeltaY / 16);
  // ... update the user interface with the new scale
});
\end{lstlisting}

The event handler is simply a function taking the event data as a parameter. In the above example we use the
\code{wheelDeltaY} property of the event to update the scale of the map.

We claim this code is fragile for two reasons. (1) The name of the event is passed as a string, so it is easy to
mispell it. (2) The callback passed as a second parameter takes a parameter \code{e} whose fields vary according to
the listened event, but developers have no way to check that the fields they’re using are indeed defined on the event
they’re listening to. For instance, in our case we use the \code{wheelDeltaY} event field that is defined only on the
\code{mousewheel} event.

\subsubsection{Asynchronous programming}

Another characteristic of RIAs is that requests to the server are often performed asynchronously: instead of asking
the browser to reload the whole page, the JavaScript code has to perform a request and to process the response, when
available, to update a part of the user interface. The following listing shows how to send a request creating a
vertex on the server and to insert it to the user interface:

\begin{lstlisting}[language=JavaScript]
var createVertex = function (text) {
  Ajax.post("/create", { content: text }, function (vertex) {
    addVertex(vertex);
  });
};
\end{lstlisting}

\code{Ajax.post} is a helper function that sends a HTTP request to the server and calls its last parameter
(that is a \emph{callback}) when the response data is available. The inverted control makes modularization harder to
achieve: in the above listing the function creating the vertex is also responsible of updating the user interface.
To relax this coupling the only option is to add a callback parameter to the \code{createVertex} function:

\begin{lstlisting}[language=JavaScript,label=async-js,caption=Callback-driven JavaScript APIs]
var createVertex = function (text, callback) {
  Ajax.get("/create", { content: text }, function (data) {
    callback(data);
  });
};

createVertex("Hello, World!", function (vertex) {
  addVertex(vertex);
});
\end{lstlisting}

However increasing the number of callbacks makes the code flow harder to follow and adds distance to the programmer's
initial intent.

Another issue with callback-driven programming arises when several dependent asynchronous computations are executed
sequentially. Consider for example the code of listing \ref{async-callback-hell} performing three consecutive Ajax
requests. Notice that the code is getting deeper toward the right. This problem is often referred to as the
“callback hell”~\cite{McKenna_Roy}. This code is also hard to reason about: when will the second \code{console.log}
statement be executed? Before or after \code{baz} has been fetched?

\begin{figure}
\begin{lstlisting}[language=JavaScript,label=async-callback-hell,caption=Sequential asynchronous calls]
Ajax.get(fooUrl(), function (foo) {
  Ajax.get(barUrl(foo), function (bar) {
    Ajax.get(bazUrl(bar), function (baz) {
      console.log(foo + bar + baz);
    });
    console.log("bar = " + bar)
  });
});
\end{lstlisting}
\end{figure}

\subsubsection{DOM manipulation}
\label{forest}

Updating the user interface usually means replacing a part of the DOM with another DOM fragment computed from data
fetched by an AJAX request. This requires writing how to compute the new DOM fragment in JavaScript. For instance
the following listing shows how to build a DOM tree representing a vertex in the mind map:

\begin{lstlisting}[language=JavaScript,label=dom-api,caption=DOM fragment creation using the native API]
var vertexDom = function (v) {
  var root = document.createElement("g");
  root.setAttribute("class", "vertex");
  root.setAttribute("transform",
    "translate(" + v.x + "," + v.y + ")");
  var rect = document.createElement("rect");
  rect.setAttribute("width", v.width);
  rect.setAttribute("height", v.height);
  var text = document.createElement("text");
  text.setAttribute("width", v.width);
  text.setAttribute("height", v.height);
  text.appendChild(document.createTextNode(v.content));
  root.appendChild(rect);
  root.appendChild(text);
  return root
};
\end{lstlisting}
% 
% \begin{lstlisting}
% var showMap = function (map) {
% 
% var vertices = function (vs) {
%   return vs.map(function (v) {
%     var g = document.createElementNS('g', 'svgns');
%     g.setAttribute('class', 'vertex');
%     g.setAttribute('transform', "translate(" + v.x + "," + v.y + ")");
%     var rect = document.createElementNS('rect', 'svgns');
%     rect.setAttribute('width', v.width);
%     rect.setAttribute('height', v.height);
%     var f = document.createElement('foreignObject');
%     f.setAttribute('x', 0);
%     f.setAttribute('y', 0);
%     f.setAttribute('width', v.width);
%     f.setAttribute('height', v.height);
%     var p = document.createElement('p');
%     p.setAttribute('style', 'height: '+v.height+'px;');
%     p.appendChild(document.createTextNode(v.content));
%     f.appendChild(p)
%     g.appendChild(rect);
%     g.appendChild(f);
%     return g
%   });
% };
% 
% var edges = function (es) {
%   return es.map(function (e) {
%     var x1 = e.orig.x + e.orig.width / 2;
%     var y1 = e.orig.y + e.orig.height / 2;
%     var x2 = e.end.x + e.end.with / 2;
%     var y2 = e.end.y + e.end.height / 2;
%     var g = document.createElementNS('g', 'svgns');
%     g.setAttribute('class', 'edge');
%     var line = document.createElement('line', 'svg');
%     line.setAttribute('x1', x1);
%     line.setAttribute('x2', x2);
%     line.setAttribute('x3', x3);
%     line.setAttribute('x4', x4);
%     return g;
%   });
% };
% 
% return vertices(map.vertices).concat(edges(map.edges));
% 
% };
% \end{lstlisting}


For instance the following call:
\begin{lstlisting}[language=JavaScript]
vertexDom({
  x: 10, y: 10,
  width: 100, height: 60,
  content: "Hello, World!"
});
\end{lstlisting}
produces a DOM tree equivalent to the following HTML:
\begin{lstlisting}[language=HTML]
<g class=vertex transform="translate(10,10)">
    <rect width=100 height=60 />
    <text width=100 height=60>
        Hello, World!
    </text>
</g>
\end{lstlisting}

Not only the \code{vertexDom} function is very verbose, but it does not reflect the markup nested structure, making
it hard to read and reason about.

Another way to build a DOM tree is to build a String containing the desired markup and then to ask the browser to
parse it as HTML:

\begin{lstlisting}[language=JavaScript]
var vertexDom = function (v) {
  return '<g class=vertex ' +
             'transform="translate('+v.x+','+v.y+')">' +
           '<rect width='+v.width+' height='+v.height+' />' +
           '<text width='+v.width+' height='+v.height+'>' +
              v.content +
           '</text>' +
         '</g>'
};
\end{lstlisting}

The above code may be more readable, however this implementation is wrong: if we call it with a content containing
brackets (\eg{} \code{"<foo>"}), they won’t be escaped and will produce a \code{foo} tag nested in the \code{text}
tag, which is not the intended behavior. So, although this way reads slightly better it’s not less error prone.

By the way, unlike the previous points, markup generation is a task that often needs to be performed from both server
and client sides. From the server-side it produces HTML pages that search engines can crawl and from the client-side
it produces DOM fragments that can be used to update the user interface. So we want to share HTML fragments definition
between both server and client sides to get consistency in the rendering and to avoid duplication.

HTML template engines like Mustache\footnote{\href{http://mustache.github.com/}{http://mustache.github.com/}} or
Closure Templates\footnote{\href{https://developers.google.com/closure/templates/}{https://developers.google.com/closure/templates/}}
aim to make it simpler the definition of DOM fragments by providing a convenient syntax to describe the HTML
structure and allowing the insertion of dynamic expressions in a safe way. Some template engines can be used on both
client-side and server-side, however none is statically typed or has a practical expression language: dynamic content
can only be provided as a map of key-value pairs (rather than typed values) and cannot be processed for
presentational purposes from within the template.

\subsection{Assessment}
\label{assessment}

In the previous section we presented the three main tasks performed by the JavaScript code in RIAs: event handling,
asynchronous programming and DOM manipulation. We noticed the following issues:

\subsubsection{Lack of static checks}

Dynamic typing may give programmers more flexibility but can make it harder for little scripts to grow into mature
and robust code bases and to perform refactorings~\cite{Meijer04_StaticDynamic}. For instance, in the case of RIAs, a
mispell in an event name may break the program behavior without anyone getting a sensible error message.

\subsubsection{Code hard to reason about and to modularize}

Callback-driven APIs are very common in JavaScript but their inverted control makes the code flow hard to follow and
hampers modularization. Furthermore, native APIs are too verbose, making the code hard to read.

\subsubsection{Sharing type-safe code between clients and servers is hard to achieve}

The lack of static checks is even harder to tackle in the case of code shared between client and server sides. If one
writes the expression \code{xs.size == 0}, how should it be translated to the client-side environment
(JavaScript) and to the server-side environment (\eg{} the Java Virtual Machine)? Several solutions are valid,
depending on the meaning of the expression: in JavaScript it could be translated as \code{xs.size === 0} if \code{xs}
refers to an object, or as
\code{xs.length === 0} if \code{xs} refers to a collection (in JavaScript the property to get the size of a
collection is named \code{length}). So we need to define a proper expression language and to define how it should be
translated for the client-side environment and the server-side environment, but such a task requires a high effort
and is hard to achieve in an extensible way (so users can still integrate their own data types in expressions instead
of being restricted to a set of supported types).

\section{A DSL for Web Programming}
\label{solution}

JavaScript libraries could address some of the challenges presented above, but addressing type safety and
asynchronous programming issues require language modifications (\eg{} to bring a type system and a sequencing
notation). Defining a language requires a high effort, especially to build development tools for the language so we
chose to define our language as a compiled embedded DSL in Scala.

\subsection{Introduction to Lightweight Modular Staging}
\label{intro-lms}

\subsubsection{Overview}

We use the Lightweight Modular Staging framework (LMS) to define our compiled embedded DSL. The main idea is that a
program written using a DSL is evaluated in two stages (or steps): the first stage builds an intermediate
representation of the program and the second stage transforms this intermediate representation into executable code
(figure \ref{lms-diagram}).

\begin{figure}
  \centering
  \includegraphics[width=7cm]{lms.pdf}
  \caption{Compilation of a program using LMS. An initial Scala program using embedded DSLs (on the left) evaluates
  to an intermediate representation from which the final program’s code is generated (on the right).}
  \label{lms-diagram}
\end{figure}

The bindings between stages are type-directed: a value of type \code{Rep[Int]} in the first stage will yield a value
of type \code{Int} in the second stage. If you consider the following code:
\begin{lstlisting}
val inc: Rep[Int] => Rep[Int] =
  x => x + 1
\end{lstlisting}
The function looks like
a regular Scala function excepted that its parameter type and its return type are wrapped in the \code{Rep[T]} type
constructor that denotes intermediate representations. The \code{+} operator has been defined on \code{Rep[Int]}
values and returns the intermediate representation of an addition. Finally, the \code{inc} function returns the
intermediate representation of a computation yielding the number following the value of the parameter \code{x}.

You can get a \code{T} value from a \code{Rep[T]} value by generating code from the intermediate representation and
compiling it:
\begin{lstlisting}
val compiledInc: Int => Int =
  compile(inc)
\end{lstlisting}
The \code{compile} function takes a staged program of type \code{Rep[A] => Rep[B]} and returns a final program of
type \code{A => B}.

The intermediate representation implementation is hidden for users but DSLs authors have to provide the corresponding
intermediate representation of each construct of their language. For that purpose, LMS comes with an extensible
intermediate representation implementation defining computations as a graph of statements. In the case of the
\code{inc} function, this graph contains a \code{Plus} node applied on a \code{Sym} node (the \code{x} parameter) and
a \code{Const} node (the literal value \code{1}).

Then, the code generation process consists in sorting this graph according to expressions dependencies and to emit
the code corresponding to each node. The listings \ref{codegen-js} and \ref{codegen-scala} show the JavaScript and
Scala generated code for the \code{inc} function:
\begin{multicols}{2}
\lstinputlisting[language=JavaScript, caption=JavaScript code generation, label=codegen-js]{inc.js}
\lstinputlisting[caption=Scala code generation, label=codegen-scala]{inc.scala}
\end{multicols}

Defining a DSL consists in three steps, each defining:

\begin{itemize}
\item The concrete syntax: an abstract API manipulating \code{Rep[_]} values~;
\item The intermediate representation: an implementation of the concrete syntax in terms of statement nodes~;
\item A code generator for the intermediate representation: a \emph{pretty-printer} for each DSL statement node.
\end{itemize}

\subsubsection{Example: null references}

As an illustration of the staging mechanism, we present a simple DSL to handle null references. This DSL provides an
abstraction at the stage-level that is removed by optimization during the code generation.

Null references are a known source of problems in programming languages~\cite{Hoare09_Null,Nanda09_Null}. For
example, consider the following typical JavaScript code finding a particular widget in the page and a then particular
button in the widget:

\begin{lstlisting}[language=JavaScript,label=null-unsafe,caption=Unsafe code]
var loginWidget = document.querySelector("div.login");
var loginButton = loginWidget.querySelector("button.submit");
loginButton.addEventListener("click", function (e) { ... });
\end{lstlisting}

The native \code{querySelector} method returns \code{null} if no node matched the given selector in the document. If
we run the above code in a page where the widget is not present, it will throw an error and stop further JavaScript
execution. We can write defensive code to handle \code{null} cases, but it leads to very cumbersome code:

\begin{lstlisting}[language=JavaScript,label=null-defensive,caption=Defensive programming to handle null references]
var loginWidget = document.querySelector("div.login");
if (loginWidget !== null) {
  var loginButton = loginWidget.querySelector("button.submit");
  if (loginButton !== null) {
    loginButton.addEventListener("click", function (e) { ... });
  }
}
\end{lstlisting}

We want to define a DSL that has both the safety and performance of listing \ref{null-defensive} but the
expressiveness of listing \ref{null-unsafe}. We can get safety by wrapping potentially null values of type
\code{Rep[A]} in a container of type \code{Rep[Option[A]]} requiring explicit dereferencing, we can get
expressiveness by using the Scala \code{for} notation for dereferencing, and finally we can get performance by
generating code that does not actually wraps values in a container but instead checks if they are \code{null} or not
when dereferenced. The wrapping container exists only at the stage-level and is removed during the code generation.
Here is a Scala listing that uses our DSL (implementation details are given in section \ref{implementation}):

\begin{lstlisting}
for {
  loginWidget <- document.find("div.login")
  loginButton <- loginWidget.find("submit.button")
} loginButton.on(Click) { e => ... }
\end{lstlisting}

The evaluation of the above listing produces a graph of statements from which JavaScript code equivalent to
listing \ref{null-defensive} is generated.

The remaining of this section describes the design and the implementation of DSLs for Web programming using LMS.

\subsection{Event Handling}

We want to bring safety to the event handling API so that developers cannot mispell an event name and cannot attempt
to read a property that is not defined on the type of the handled event. The difficulty comes from the fact that the
type of data passed to the handler varies with the event name. For instance, in listing \ref{event-js} the
handler processes \code{MouseWheelEvent} values because it listens to \code{mousewheel} events. Values of type
\code{MouseWheelEvent} have a property \code{wheelDeltaY} but that’s not the case of an event data of type
\code{KeyboardEvent}, for example.

A possible solution could be to define a distinct method for each event instead of the single \code{addEventListener}
method, so each method takes a handler with the according event type:

\begin{lstlisting}
window.onKeyUp { e: Rep[KeyboardEvent] =>
  println(e.key)
}
window.onMouseWheel { e: Rep[MouseWheelEvent] =>
  println(e.wheelDeltaY)
}
\end{lstlisting}

In the above listing, the \code{onKeyUp} method attaches an event handler for the \code{keyup} event that uses values
of type \code{KeyboardEvent}, and the \code{onMouseWheel} method does the same for \code{mousewheel} events that use
values of type \code{MouseWheelEvent}.

However, implementing this solution requires a high effort because we have to define as many methods as there are
events. We want to provide a single polymorphic method similar to the native API. To achieve that, we need to encode
the dependency relation between an event name and its corresponding data at the type-level. This dependency can
naturally and elegantly be encoded using dependent method types~\cite{Oliveira10_Typeclasses}:

\begin{lstlisting}
class EventDef {
  type Data
}

def on(ev: EventDef)(handler: Rep[ev.Data] => Rep[Unit]): Rep[Unit]
\end{lstlisting}

(We renamed \code{addEventListener} to \code{on}, for the sake of brevity). An \code{EventDef} value represents an
event that carries its corresponding event data type in its \code{Data} type member. The \code{on} method takes a
parameter \code{ev} of type \code{EventDef} and a \code{handler} parameter whose type refers to the \code{Data}
member of the \code{ev} parameter, so the type of the handler depends on the \code{ev} value. We can then define the
\code{keyup} and \code{mousewheel} events as follows:

\begin{lstlisting}
object KeyUp extends EventDef { type Data = KeyboardEvent }
object MouseWheel extends EventDef { type Data = MouseWheelEvent }
\end{lstlisting}

The following Scala listing generates code equivalent to listing \ref{event-js} and is completely type-safe: if
the user misspells the event name or tries to use an undefined property on an event his program won’t compile.

\begin{lstlisting}
window.on(MouseWheel) { e =>
  scale = Math.round(scale + e.wheelDeltaY / 16)
}
\end{lstlisting}

\subsection{Asynchronous Programming}

The previous work on js-scala \cite{Kossakowski12_JsDESL} showed how to make asynchronous programming more
convenient by making asynchronous calls looking like synchronous calls (\ie{} returning a value instead of taking a
callback as parameter). This work was based on the Scala continuations compiler plugin. We claim that, although this
programming model removes the “callback hell”, it can make the code hard to reason about because there is no explicit
distinction between synchronous and asynchronous computations.

We propose a DSL that explicitly reflects the asynchronous nature of computations in their types and provides methods
turning them into first-class citizens. The DSL is monadic so we can solve the callback hell problem thanks to the
Scala \code{for} notation.

For instance, listing \ref{async-first-class} shows how the listing \ref{async-js} can be re-written using our DSL.
The \code{createVertex} function now returns an asynchronous value instead of taking a callback as
parameter. Then, the \code{for} expression allows us to get the vertex, when available, and to insert it on the user
interface. By making the \code{createVertex} function return an asynchronous value instead of taking a callback as
a parameter, the code is easier to modularize into loosely coupled parts.

\begin{figure}
\centering
\begin{lstlisting}[caption=Asynchronous values are first class citizen,label=async-first-class]
def createVertex(text: Rep[String]): Rep[Future[Vertex]] =
  Ajax.post[Vertex]("/create", new Record { val content = text })

for (vertex <- createVertex("Hello, World!")) {
  addVertex(vertex)
}
\end{lstlisting}
\end{figure}

\begin{figure}
\centering
\begin{lstlisting}[caption=No callback hell,label=async-no-callback]
for {
  foo <- Ajax.get(fooUrl())
  bar <- Ajax.get(barUrl(foo))
  _ <- future(println("bar = " + bar))
  baz <- Ajax.get(bazUrl(bar))
} println(foo + bar + baz)
\end{lstlisting}
\end{figure}

Listing \ref{async-no-callback} translates the callback hell example (listing \ref{async-callback-hell}) using
our DSL. The \code{for} notation can intuitively be thought of as a sequencing notation: whenever the response of the
first Ajax request is available, the next statement is executed, and so on. There is no nested callbacks and the
order of execution is directly reflected by the order of statements.

An asynchronous value of type \code{Rep[A]} is modelled by a value of type \code{Rep[Future[A]]}. Because Scala’s
\code{for} notation is just syntactic sugar for methods \code{foreach}, \code{map} and \code{flatMap}, we are
able to define our DSL by just defining these methods on \code{Rep[Future[A]]} values, with the following semantic:
\begin{itemize}
\item \code{foreach(f: Rep[A] => Rep[Unit]): Rep[Unit]}, eventually does something with the value when available~;
\item \code{map(f: Rep[A] => Rep[B]): Rep[Future[B]]}, eventually transforms the value when available~;
\item \code{flatMap(f: Rep[A] => Rep[Future[B]]): Rep[Future[B]]} also eventually transforms the value when available~;
\end{itemize}

Asynchronous values can be transformed using the \code{map} and \code{flatMap} methods, turning them into first-class
citizens: functions can take them as parameters and return them.

\begin{figure}
\begin{multicols}{2}
\begin{lstlisting}[caption=Parallel computations in Scala,label=async-parallel-1]
val fooAsync = Ajax.get("/foo")
val barAsync = Ajax.get("/bar")
for {
  foo <- fooAsync
  bar <- barAsync
} println(foo + bar)
\end{lstlisting}
\vfill
\columnbreak
\begin{lstlisting}[language=JavaScript,caption=Generated JavaScript code,label=async-parallel-2]
var x1 = { cs: [] };
AjaxGet("/foo", x1);
var x2 = { cs: [] };
AjaxGet("/bar", x2);
foreach(x1, function (foo) {
 foreach(x2, function (bar) {
  var x3 = foo + bar;
  console.log(x3);
 });
});
\end{lstlisting}
\end{multicols}
\end{figure}

Listing \ref{async-parallel-1} defines two asynchronous computations running in parallel and listing
\ref{async-parallel-2} shows the generated JavaScript code (we renamed some identifiers for the sake of readability).
The \code{x1} and \code{x2} values encode the asynchronous results of the Ajax requests, they contain an array of
callbacks (\code{cs}, initially empty) to call when the result is available. The \code{AjaxGet} function code has
been omitted, it creates a \code{XMLHttpRequest} object that sends a HTTP request and completes the value of its
last parameter with the response, when received. Completing an asynchronous value means defining a \code{v} field
on it containing the actual value, and calling all pending callbacks that are in the \code{cs} field. The
\code{foreach} code has also been omitted, it registers a callback on an asynchronous value or calls the callback
directly with the value if this one is already available.

\subsection{DOM Definition}

In this section we show how we can define a template engine as an embedded DSL with minimal effort. This template
engine is statically typed and able to insert dynamic content in a safe way. It provides a powerful expression
language, requires no extra compilation step and can be used on both client-side and server-side.

Because the template engine is defined as en embedded DSL, we can reuse Scala’s constructs:

\begin{itemize}
\item a function taking some parameters and returning a DOM fragment directly models a template taking parameters and
returning a DOM fragment~;
\item the type system typechecks template definitions and template calls~;
\item the Scala language itself is the expression language~;
\item compiling a template is the same as compiling user code.
\end{itemize}

So the only remaining work consists in defining the DSL vocabulary to define DOM nodes. We provide a \code{tag}
function to define a tag and a \code{text} function to define a text node.

\begin{figure}
\begin{lstlisting}[label=forest-hello,caption=DOM definition DSL]
def vertexDom(v: Rep[Vertex]) =
    tag("g", "class"->"vertex",
             "transform"->("translate("+v.x+","+v.y+")"))(
        tag("rect", "width"->v.width, "height"->v.height)(),
        tag("text", "width"->v.width, "height"->v.height)(
            text(v.content)
        )
    )
\end{lstlisting}
\end{figure}

Listing \ref{forest-hello} uses our DSL and generates a code equivalent to listing \ref{dom-api}. The readability has
been highly improved: nesting tags is just like nesting code blocks, HTML entities are
automatically escaped in text nodes, developers have the full computational power of Scala to inject dynamic data and
DOM fragments definitions are written using functions so they compose just as functions compose. These benefits come
with no performance loss because the DSL generates code building DOM fragments by using the native JavaScript API.

\subsubsection{Reuse the DOM definition DSL on server-side}

Our DSL is equivalent to a template engine with Scala as the expression language. Making it usable on both server and
client sides was surprisingly as simple as defining another code generator for the DSL, producing Scala code.

For instance, the template written in listing \ref{forest-hello} produces the following Scala code usable on
server-side (the generated code for client-side is roughly equivalent to listing \ref{dom-api}):

\begin{lstlisting}
def vertexDom(v: Vertex) = {
  val x0 =
    <text width="{v.width}" height="{v.height}">
      {v.content}
    </text>
  val x1 = <rect width="{v.width}" height="{v.height}" />
  val x2 =
    <g class="vertex" transform="translate({v.x},{v.y})">
      {List(x0, x1)}
    </g>
  x2
}
\end{lstlisting}

We are able to tackle the code sharing issues described in section \ref{assessment} because of the embdedded nature
of our DSLs: dynamic content of templates is written using embedded DSLs too, so their translation into JavaScript
and Scala is managed by their respective code generators.

\subsection{Leveraging the Scala Type System on the Client-Side}

This section presents some more general purpose improvements of JavaScript based on type-directed mechanisms of
Scala.

% \subsubsection{State monad}
% 
% Managing the state of an application is cumbersome and fragile in JavaScript due to the lack of encapsulation
% constructs. For example, consider the following function incrementing a counter and returning its previous value:
% \begin{lstlisting}[language=JavaScript,label=state-fragile,caption=Fragile state handling]
% var x;
% var inc = function () {
%   var prev = x;
%   x = x + 1;
%   return prev
% };
% 
% // Usage
% x = 42;
% inc();
% var y = inc();
% alert(y);
% \end{lstlisting}
% This code suffers from two problems: the variable \code{x} is global and if the user calls the \code{inc} function
% without first initializing the \code{x} variable the behavior will be unexpected.
% 
% To workaround these issues, developers can wrap the variable declaration and the \code{inc} function code in a
% factory function. Thus the state is hidden and developers may not forget the initialization:
% 
% \begin{lstlisting}[language=JavaScript,label=state-encapsulated,caption=State encapsulation within a function]
% var incFactory = function (init) {
%   var x = init;
%   return function () {
%     var prev = x;
%     x = x + 1;
%     return prev
%   }
% };
% 
% // Usage
% var inc = incFactory(42);
% inc();
% var x = inc();
% alert(x);
% \end{lstlisting}
% 
% The code is now safer, but it is also bigger, and it still uses a mutable state. It’s known that mutable objects in
% the code make this one harder to reason about~\cite{Grogono94_Immutability,Kjolstad11_Immutability}. Getting rid of
% mutable objects is simple: instead of modifying a state, a function takes its initial value as a parameter and
% returns its new value in its result:
% 
% \begin{lstlisting}[language=JavaScript,label=state-explicit,caption=Explicit state threading]
% var inc = function (state) {
%   return {
%     state: state + 1,
%     value: state
%   }
% };
% 
% // Usage
% var x1 = inc(42);
% var x2 = inc(x1.state);
% alert(x2.value);
% \end{lstlisting}
% 
% However, explicitly threading the state in all functions parameters is not desired because of the syntactic and
% performance cost of adding an extra parameter to each function and of returning two results instead of one.
% Furthermore, manually passing the result of each previous call to the next one is error prone.
% 
% The State monad~\cite{Wadler92_StateM} is a functional programming pattern that avoids explicitly threading the state
% in functions using it or modifying it. In Scala, the \code{for} notation provides an elegant way to sequence monadic
% computations, and thus to implicitly thread a state across computations, as shown in the following listing:
% 
% \begin{lstlisting}[label=state-monad,caption=Implicitly threaded state using the State Monad]
% val inc = for {
%   x <- get[Int]
%   _ <- put(x + 1)
% } yield x
% 
% // Usage
% val usage = for {
%   _ <- inc
%   x <- inc
% } yield alert(x)
% usage.init(42)
% \end{lstlisting}
% 
% The \code{get} and \code{put} primitives are part of the State monad DSL, they allow to retrieve the current state
% and to change it. The \code{usage} value is a reusable piece of program that calls twice the \code{inc} function
% and prints the result of the second call. The last line of the listing runs the \code{usage} program on an initial
% state.
% 
% The State monad programming model has the advantages but not the shortcomings of both listings
% \ref{state-encapsulated} and \ref{state-explicit} because there is no global variable (the state is implicitly
% threaded thanks to the State monad but state modifications explicitly use the \code{get} and \code{put} primitives)
% and everything is immutable.
% 
% Furthermore, our implementation produces efficient imperative code using variables instead of functions passing the
% state through. To achieve that, we transform the intermediate representation of the stack of state modifications
% produced by the \code{for} sequences into an equivalent intermediate representation using regular variables. Finally,
% the listing \ref{state-monad} compiles to code equivalent to the listing \ref{state-fragile} so that there is no
% abstraction penalty.

\subsubsection{\emph{Ad hoc} polymorphism}

Because of the dynamically typed nature of JavaScript, when calling a function there is no proper way to select a
specialized implementation according to the function’s parameters types. JavaScript is only able to dispatch
according to a method receiver prototype, \eg{} if one writes \code{foo.bar()} the JavaScript runtime will look into
the prototype of the \code{foo} object for a property named \code{bar} and will call it. So, the only way to achieve
\emph{ad hoc} polymorphism on JavaScript objects consists in defining the polymorphic function on the prototypes of
the objects. However, modifying existing object prototypes is considered bad
practice~\cite{Zakas12_MaintainableJs}. Another way could consist in manually coding the dispatch logic, by
registering supported data types at the beginning of the program execution, as described in section 2.4.3
of~\cite{Abelson83_SICP}, but this solution is painful for developers and incurs a performance overhead.

We propose to achieve \emph{ad hoc} polymorphism using
typeclasses~\cite{Wadler89_AdhocPolymorphism,Odersky06_Typeclasses,Oliveira10_Typeclasses} so that it supports
retroactive extension without modifying objects prototypes because it is type-directed: the dispatch happens at
compile-time rather than at runtime.

\begin{figure}
\begin{lstlisting}[label=polymorphism,caption=Ad hoc polymorphism using typeclasses]
// Interface
case class Show[A](show: Rep[A => Node])

// Polymorphic function
def listWidget[A : Show](items: Rep[List[A]]): Rep[Node] = {
  tag("ul")(
    for (item <- items) yield {
      tag("li")(implicitly[Show[A]].show(item))
    }
  )
}

// Type `User`
type User = Record { val name: String; val age: Int }
// Implementation of Show for a User
implicit val showUser = Show[User] { user =>
  tag("span", "class"->"user")(
    text(user.name + "(" + user.age + " years)")
  )
}

// Type `Article`
type Article = Record { val name: String; val price: Double }
// Implementation of Show for an Article
implicit val showArticle = Show[Article] { article =>
  tag("span")(
    text(article.name),
    tag("strong")(text(article.price + " Euros"))
  )
}

// Main program
def main(users: Rep[List[User]], articles: Rep[List[Article]]) = {
  document.body.append(listWidget(users))
  document.body.append(listWidget(articles))
}
\end{lstlisting}
\end{figure}

Listing \ref{polymorphism} demonstrates how to define a polymorphic \code{listWidget} function that returns a DOM
tree containing the representation of a list of items. The \code{Show[A]} typeclass defines how to produce a DOM tree
for a value of type \code{A}. It is used by the \code{listWidget} function to get the DOM fragments of the list
items. The listing shows how to reuse the same \code{listWidget} function to show a list of users and a list of
articles.

\subsubsection{Type coercion}

JavaScript comes with only one numeric type, \code{Number}, that represents double-precision 64-bit values. If
developers want to use another numeric data type, \eg{} representing rational numbers, they can’t use the native
arithmetic operators (\code{+}, \code{-}, \etc) on them, making the code less readable because the same concepts
(\eg{} adding two numeric values) are described by different operators or methods. Furthermore, the code is also
harder to write when it comes to mix different types of numeric values. Indeed, this requires to manually take care
of their compatibility: before adding a rational number with a \code{Number} value, developers have to convert the
former in the latter’s type. Consider as an example the listing \ref{type-coercion} mixing rational numbers and
native numbers.

\begin{lstlisting}[language=JavaScript,label=type-coercion,caption=Mixing integer and floating-point arithmetic in
JavaScript.]
// i and j are rational numbers, x and y are native numbers
var main = function (i, j, x, y) {
  console.log(rat_plus(i, j));
  var m = rat_toNumber(i) + y;
  var n = x + rat_toNumber(j);
  console.log(m + n);
};
\end{lstlisting}


Our DSL solves these problems by defining numeric operations in a safe and extensible way: each operation is a
polymorphic method and operand coercion is expressed using functional dependencies~\cite{Jones00_FunDeps}. It allows
developers to use a homogeneous syntax for arithmetic operations with different numeric types and to mix
heterogeneous types in a same operation. For example, the add operation is defined as follows:

\begin{lstlisting}
def numeric_plus[A : Numeric](lhs: Rep[A], rhs: Rep[A]): Rep[A]
\end{lstlisting}

The \code{A : Numeric} syntax means that the function is polymorphic on any type \code{A}, as long as there is an
available \code{Numeric[A]} value.

Then we add a \code{+} method to any \code{Rep[_]} value, using an implicit class, so we can use an homogeneous
syntax to write arithmetic operations whatever the numeric type of values this operation is applied on:

\begin{lstlisting}
implicit class NumericOps[A : Numeric](lhs: Rep[A]) {
  def + (rhs: Rep[A]) = numeric_plus(lhs, rhs)
}
\end{lstlisting}

The above code allows to add two values of any numeric type (\code{Int}, \code{Rational}, \etc) using the \code{+}
operator, but it does not handle operands coercion yet. To do so, we want to express that an expression
\code{a + b} is valid either if \code{a} and \code{b} have the same numeric type, or if one of them has a numeric
type and the other can be converted to this numeric type. The result type of such an expression depends on the types
of the operands, \eg{} an integer and a double value produce a double value, two integer values produce another
integer value. We express these constraints using functional dependencies:

\begin{lstlisting}
implicit class NumericOps(lhs: Rep[A]) {
  def + [B, C](rhs: Rep[B])(implicit ev: (A ~ B) ~> C): Rep[C] =
    numeric_plus(ev.lhs(lhs), ev.rhs(rhs))
}
\end{lstlisting}

The \code{ev} parameter has type \code{(A ~ B) ~> C}, which means \emph{combining a \code{A} and a \code{B} gives a
\code{C}}. Then we need to define which combinations of \code{A}, \code{B} and \code{C} are valid:

\begin{lstlisting}[caption=Numeric operands constraints,label=type-coercion-constraints]
implicit def sameType[A : Numeric] =
  new ((A ~ A) ~> A)(identity, identity)
implicit def promoteLhs[A, B : Numeric](implicit aToB: A => B) =
  new ((A ~ B) ~> B)(a => convert[B](a), identity)
implicit def promoteRhs[A, B : Numeric](implicit aToB: A => B) =
  new ((B ~ A) ~> B)(identity, a => convert[B](a))
\end{lstlisting}

The \code{sameType} value says that two values of type \code{A} give another value of type \code{A}. The
\code{promoteLhs} value says that a value of type \code{A} and a value of a numeric type \code{B} can be used as
operands as long as there is a way to convert the value of type \code{A} to a value of type \code{B} (so the left
hand side is promoted to the type \code{B}). The \code{promoteRhs} does the same for the right hand side.

\begin{figure}
\begin{lstlisting}[label=type-coercion-solution,caption=Type-coercion automatically handled by our DSL]
def main(i: Rep[Rational], j: Rep[Rational],
         x: Rep[Double], y: Rep[Double]) = {
  println(i + j)
  // i is promoted to Rep[Double], m has type Rep[Double]
  val m = i + y
  // j is promoted to Rep[Double], n has type Rep[Double]
  val n = x + j
  println(m + n)
}
\end{lstlisting}
\end{figure}

Listing \ref{type-coercion} can be rewritten as shown in listing \ref{type-coercion-solution} with our DSL.
The \code{+} operator can be safely used to add rational and floating-point numbers and type promotion is
automatically handled by the type system. It is worth noting that the \code{Rational} data type can be written
independently of the type coercion system.

\subsection{Discussion}

\subsubsection{Benefits of the compiled embedded approach}

We implemented our language as a compiled embedded DSL in Scala. The process of generating code from a DSL is usually
described as a two steps process: a program first evaluates to an intermediate representation and then the final
program’s code is generated from this intermediate representation, with the opportunity to generate efficient code
by applying domain specific optimizations. We think it’s worth considering a third step that occurs before the
program evaluation: its compilation. This step affects DSLs design because their embedded nature let them reuse the
host language features (\eg{} the type system or syntactic sugars) to implement their own features. The following
paragraph gives an overview of the different mechanisms used to implement our DSLs.

First, features like type coercion and \emph{ad hoc} polymorphism only rely on the type system, so they operate during
the compilation. Then, during the evaluation, the DSL constructs build an intermediate representation of the program,
for instance the DOM definition DSL builds a tree of DOM nodes. Last, the code generator produces the final program
using the domain specific information available in the intermediate representation to generate efficient code, for
example the Option monad code generator produces code checking against nullity before dereferencing a value.

An important consequence of the implementation as compiled embedded DSLs is the low effort required to be able to
share code between server and client sides. The other ways to define DSLs compiling to multiple backends are either
to define a brand new language so the compilation generates appropriate code for each target (\eg{} Opa), or to
define a library within a host language that already compiles to several targets (\eg{} GWT, Kotlin). However, the
first way requires a high effort or leads to defining several small languages that are hard to integrate seamlessly,
and the second way does not give the opportunity to specialize the generated code according to the targets (so you
can’t generate, from the same library, code building DOM fragments on the client-side and code building XML trees on
the server-side).

Compiled embedded DSLs have the advantages of both approaches because they are simply defined as libraries but they
let developers specialize the generated code according to each target. This opportunity made it possible to define,
as a library, the HTML templating DSL generating code building DOM fragments on client-side and code building XML
trees on server-side.

% Furthermore, templates can be shared between client and server sides. Opa is also a language making it possible to
% share statically typed templates with a convenient expression language between client and server sides. In Opa they
% made this possible because HTML templating is part of the language itself. However, creating a brand new language for
% each problem requires a high effort, especially since the effort to define common language constructs is duplicated.
% To reduce the effort, the solution consists in implementing abstractions specific to a given problem as libraries on
% top of a general purpose language. For instance, Kotlin provides an embedded DSL similar to ours to define HTML
% fragments. Because the Kotlin language can be compiled to JavaScript and to JVM bytecode, HTML templates can be
% shared between client and server sides. However, their DSL does not produce code building DOM fragments on
% client-side. Actually, on both server-side and client-side the output is the same: an abstract tree containing the
% HTML fragment. So, users need to transform this AST into a proper DOM fragment using a function specific to the
% client-side. Kotlin and similar approaches (Fay, ClojureScript, GWT) can’t generate specialized code for a given
% abstraction because their translation scheme is based on the initial program source code: if an abstraction is
% defined as a library, they will generate code reimplementing the library on each backend (client-side and
% server-side). There is no way to specialize the generated code for a given library.
% 
% On one hand defining a new language (or modifying an existing language) to integrate a concept specific to a problem
% is not desired either because it requires a high-effort to define a full-featured language or because several small
% languages are hard to integrate seamlessly together. On the other hand, defining a concept specific to a problem as a
% library allows developers to concentrate their effort on the concept itself and to reuse the host language
% infrastructure, but they have no way to specialize, for each backend, the code generated by the compiler for their
% concept.

\subsubsection{Lack of a data type definition DSL}

On the other side of the coin, because that is not possible to define a library without defining how to translate it
on both server and client sides, there is no simple way to let DSLs users define their own libraries. This feature
comes almost for free with approaches like GWT, Fay or Kotlin because they derive the client-side program and the
server-side program from the initial program source (that contains data type definitions such as classes
definitions). In our case, the client-side program and the server-side program are derived from the intermediate
representation produced by the evaluation of the initial program. So, only concepts reified in an intermediate
representation during this evaluation can be part of the final programs. However regular Scala’s classes definitions
are not reified in an intermediate representation (it would mean that the constructor of a type \code{A} would yield
a value of type \code{Rep[A]}). Scala-virtualized~\cite{Moors12_Virtualized} provides such a mechanism but is 
limited to record types and provides only projection functions, so for more complex cases users have to write some
repetitive and boilerplate code.

In summary, the compiled embedded approach may require more work to define custom data types but gives control on
the way these data types will be encoded for each target platform (\eg{} the JavaScript code generator uses native
arrays to encode the lists of the list manipulation DSL).

However, the next release of Scala will have support for macros making it possible to generate reified data types
from a concise syntax without even relying on a compiler extension such as Scala-virtualized.

\subsubsection{Custom code generation to handle browsers incompatibilities}

Each component of a DSL is defined in a trait and each corresponding code generator for a given target is also
defined in a trait. The Scala language allows developers to mix several traits together, so they can build their
language by picking the DSL traits they want to use.

Furthermore, a code generator can be tweaked by defining a sub-trait specializing some of its methods. This feature
can be used to handle cross-browser incompatibilities. For instance we have written code generators specializing the
output for some statement nodes in order to handle Internet Explorer incompatibilities.

% For example, the \code{forEach} method on JavaScripts arrays was not supported by Internet Explorer before version 9. As some users may still have old versions of Internet Explorer we want to send them a specialized version of JavaScript files to handle this incompatibility. We can do that by extending the code generator for the \code{List} operations to specialize the generation of the \code{ListForeach} node to generate a JavaScript \code{for} loop instead of a \code{forEeach} call:
% 
% \begin{lstlisting}
% trait JSGenListIE extends JSGenList {
%  import IR._
%  override def emitNode(sym: Sym[Any], rhs: Def[Any]) =
%   rhs match {
%    case ListForeach(l, x, b) =>
%     var i = fresh[Int]
%     stream.println("for (var "+quote(i)+" = 0 ; "+
%                         quote(i)+" < "+quote(l)+".length ; "+
%                         quote(i)+"++) {")
%     emitValDef(x, quote(l)+"["+quote(i)+"]")
%     emitBlock(b)
%     stream.println("}")
%    case _ => super.emitNode(sym, rhs)
%   }
% }
% \end{lstlisting}
% 
% Internet Explorer suffers from some others incompatibilities, \eg{} its events API is different of the standard. On the same way we can define a \code{JSGenDomIE} trait generating code targeting the Internet Explorer’s events API for the \code{Dom} DSL.
% 
% Then, we can pack together all the traits handling Internet Explorer’s incompatibilities in a \code{IESupport} trait:
% 
% \begin{lstlisting}
% trait IESupport extends JSGenListIE with JSGenDomIE {
%   val IR: ListOpsExp with DomExp
% }
% \end{lstlisting}
% 
% And, finally, we can mix this \code{IESupport} trait with any JavaScript code generator to target Internet Explorer:
% 
% \begin{lstlisting}
% val jsGen = new JSGen with IESupport {
%   val IR: prog.type = prog
% }
% \end{lstlisting}

\section{Implementation and Evaluation}
\label{validation}

\subsection{Implementation}
\label{implementation}

This section presents relevant implementation details of the js-scala DSL\footnote{The complete implementation is
available at \href{http://github.com/js-scala}{http://github.com/js-scala}}.

\subsubsection{Type-directed DSL constructs}

The \emph{ad hoc} polymorphism feature of our DSL is directly borrowed from Scala’s typeclasses encoding but the type
coercion feature required to define a type-level DSL to express constraints. Numeric operations take an implicit
value of type \code{(A \~ B) ~> C}. This type is actually a syntactic sugar for the type \code{\~>[\~[A, B], C]}
(Scala supports an infix notation for type constructors of arity two). The \code{\~\>} type also takes two value
parameters, saying how to obtain a value of the target type for each operand. Here is the definition of the
\code{\~\>} type:

\begin{lstlisting}
class ~>[A <: Args, B : Numeric](
  val lhs: Rep[A#Lhs] => Rep[B],
  val rhs: Rep[A#Rhs] => Rep[B]
)
trait Args { type Lhs; type Rhs }
type ~[A, B] = Args { type Lhs = A; type Rhs = B }
\end{lstlisting}

The \code{\~} type is just an alias for the \code{Args} type to get the infix notation. The \code{Args} type
aggregates the types of the operands (\code{Lhs} and \code{Rhs}) involved in a binary operation.

When a numeric operation is used, the Scala compiler fills the required implicit parameter of type
\code{(A ~ B) ~> C} by looking for an implicit value of this type that satisfies the operands types and fixes the
\code{C} type parameter value. The defined implicit values are given in lisiting \ref{type-coercion-constraints}.
For example, for a numeric operation involving a \code{Rep[Int]} value and a \code{Rep[Double]} value, the
\code{sameType} value is not applicable because its \code{A} type parameter cannot match both \code{Int} and
\code{Double}, the \code{promoteRhs} value is not applicable because there is no implicit conversion from
\code{Double} to \code{Int} but the \code{promoteLhs} value is applicable and fixes the \code{C} type parameter to
\code{Double}. So, such an operation would promote the \code{Rep[Int]} parameter into a \code{Rep[Double]} value and
would return a \code{Rep[Double]} value.

\subsubsection{Intermediate representation construction}

Every DSL construct producing code in the final program is first reified in an intermediate representation. Listing
\ref{option-impl} shows extracts of both the abstract DSL interface of the \code{null} reference handling DSL and its
implementation building an intermediate representation of values dereferencing.

\begin{figure}
\begin{lstlisting}[caption=Null reference handling DSL,label=option-impl]
// DSL interface
trait OptionOps { this: Base =>
  implicit def repOptionToOps[A](o: Rep[Option[A]]) =
    new OptionOpsCls(o)
  class OptionOpsCls[+A](o: Rep[Option[A]]) {
    def isEmpty = option_isEmpty(o)
    def foreach(f: Rep[A] => Rep[Unit]) =
      option_foreach(o, f)
  }
  
  def option_isEmpty[A](o: Rep[Option[A]]): Rep[Boolean]
  def option_foreach[A](o: Rep[Option[A]],
      f: Rep[A] => Rep[Unit]): Rep[Unit]
}
// Intermediate representation
trait OptionOpsExp extends OptionOps { this: EffectExp =>
  def option_isEmpty[A](o: Exp[Option[A]]) = OptionIsEmpty(o)
  def option_foreach[A](o: Exp[Option[A]],
      f: Exp[A] => Exp[Unit]) = {
    val a = fresh[A]
    val b = reifyEffects(f(a))
    reflectEffect(OptionForeach(o, a, b), summarizeEffects(b).star)
  }
  
  case class OptionIsEmpty[A](o: Exp[Option[A]]) extends Def[Boolean]
  case class OptionForeach[A](o: Exp[Option[A]],
      a: Sym[A], block: Block[Unit]) extends Def[Unit]
}
\end{lstlisting}
\end{figure}

We limited the listing to two operations (\code{foreach} and \code{isEmpty}) for the sake of brevity. The
\code{OptionOps} trait defines the user facing DSL, it enriches \code{Rep[Option[_]]} values by providing an implicit
conversion to \code{OptionOpsCls} that defines the \code{isEmpty} and \code{foreach} methods that respectively tests
the emptiness of a value and derefences a value if not empty. These methods provide a convenient syntax to use
\code{Rep[Option[_]]} values and delegate to the \code{option_isEmpty} and \code{option_foreach} operations,
respectively, that are left abstract. The \code{OptionOpsExp} trait implements the \code{option_isEmpty} and
\code{option_foreach} methods. The \code{option_isEmpty} implementation simply returns a statement node of type
\code{OptionIsEmpty}, but the \code{option_foreach} implementation is more subtle because it has to track the
dependencies of its function parameter \code{f} (for instance, side-effects performed within the \code{f} function
must be reflected by the returned \code{OptionForeach} node).

The principle is the same for all DSLs: first, provide an abstract trait with the DSL vocabulary, then implement each
DSL construct to return a reified intermediate representation of itself. Sometimes you have the opportunity
to perform some optimizations at the evaluation level such as constants folding. For instance, the DOM definition DSL
builds trees consisting of a root node and eventually several children. If these children are known at evaluation
time we can build a node having a \code{List[Rep[Node]]} value as children instead of a \code{Rep[List[Node]]} so the
generated code will be able to inline the loop adding the children to the parent node. Listing \ref{forest-impl}
shows the relevant part of code checking if the \code{children} parameter of the \code{forest_tag} method is a
constant list (the \code{ListNew} statement node represents constant lists) and building different intermediate
representations according to this test.

\begin{figure}
\begin{lstlisting}[caption=Optimized intermediate representation for the DOM definition DSL,label=forest-impl]
trait ForestExp extends Forest with EffectExp { this: ListOpsExp =>
  def forest_tag(name: String, attrs: Map[String, Exp[String]],
      children: Exp[List[Node]]) = children match {
    case Def(ListNew(children)) =>
      Tag(name, Left(children.toList), attrs)
    case _ =>
      Tag(name, Right(children), attrs)
  }
  case class Tag(name: String,
      children: Either[List[Exp[Node]], Exp[List[Node]]],
      attrs: Map[String, Exp[String]]) extends Def[Node]
}
\end{lstlisting}
\end{figure}

\subsubsection{Code generation}

Code generation consists in traversing the statement nodes produced by the program evaluation according to their
dependencies and to emit the code corresponding to each statement. LMS already sorts the statements graph so DSL
authors just need to say how to emit code for each statement node of their DSL. Listing \ref{option-codegen} shows
such a code generator for the \code{null} reference handling DSL. The \code{emitNode} method handles
\code{OptionIsEmpty} and \code{OptionForeach} nodes. In the case of the \code{OptionIsEmpty} node, it simply
generates an expression testing if the value is \code{null}, in the case of the \code{OptionForeach} node, it wraps
the code block dereferencing the value within a \code{if} checking that the value is not \code{null}.

\begin{figure}
\begin{lstlisting}[caption=Null reference handling DSL code generator,label=option-codegen]
trait JSGenOptionOps extends JSGenEffect {
  val IR: EfffectExp with OptionOpsExp
  import IR._
  override def emitNode(sym: Sym[Any], rhs: Def[Any]) =
    rhs match {
      case OptionIsEmpty(o) =>
        emitValDef(sym, quote(o) + " === null")
      case OptionForeach(o, a, b) =>
        stream.println("if (" + quote(o) + " !== null) {")
        emitValDef(a, quote(o))
        emitBlock(b)
        stream.println("}")
      case _ =>
        super.emitNode(sym, rhs)
    }
}
\end{lstlisting}
\end{figure}

\subsection{Evaluation}

Our goal was to define, with a minimal effort, a language for RIAs development. The main challenge was to provide
programming language constructs that are both safer and more expressive without performance penalty. We focused on
the main concerns of RIA development: event handling, asynchronous programming and DOM fragments definition, as well
as on more general programming concerns: \code{null} reference handling and type safety.

Using our DSL, we were able to completely rewrite the client-side part of our mind mapping application and to
integrate it in a mainstream Web framework for the server-side part. The number of
lines of code needed to write the DOM fragments reduced by 38\%. The size of code parts dealing with events did not
change but gained type safety. Finally, code handling asynchronous computations were easier to modularize.

An interesting side-effect of the design of our DSL as a compiled embedded DSL is the ability to reuse some code
between both client and server sides. We were able to reuse DOM fragments definition on both sides and to build two
variants of the application with minimal effort. The first variant renders HTML from the server-side and the second
variant renders DOM fragments from the client-side. The flexibility to decide later where to run the logic (on
client-side or on server-side) gives more agility in the development because we can easily adapt the application. For
instance we can choose to perform the rendering on server-side if the application targets smartphones with a small
processing speed or to perform the rendering on client-side, to preserve the server CPU usage, if the application
targets desktop computers.

All these benefits came with no runtime overhead, excepted for the asynchronous programming DSL that creates, for
each asynchronous computation, a reified asynchronous value registering the callbacks to call when the value is
available.

\section{Related Works}
\label{related}

The most popular JavaScript library, jQuery~\cite{Bibeault08_jQuery}, used by more than 40\% of the top million
sites\footnote{\href{http://trends.builtwith.com/javascript}{http://trends.builtwith.com/javascript}} aims to
simplify RIA development. It handles the \code{null} references problem by wrapping each query result in a container
so before each further method call it tests the emptiness of the container and applies the operation effectively only
if the container is not empty. It provides an expressive API but the emptiness checking involves a slight performance
penalty since each result is wrapped and then unwrapped for the subsequent method invocation. jQuery also has an API
to turn asynchronous computations into first-class citizens. However, jQuery is just a library and thus cannot bring
type safety to JavaScript programs.

TypeScript\footnote{\href{http://www.typescriptlang.org/}{http://www.typescriptlang.org/}} is a language compiling to
JavaScript supporting classes, modules and soft typing. Because TypeScript is a superset of JavaScript, any valid
JavaScript program is a valid TypeScript program. Developers can progressively leverage TypeScript’s features to turn
their JavaScript sources into large, modular and more robust code bases. However, TypeScript does not address
problems specific to RIAs development like DOM fragments definition or asynchronous programming.

The Roy~\cite{McKenna_Roy} programming language is a statically typed functional programming language compiling to
JavaScript. It features global type inference, algebraic data types, pattern matching and a sequencing notation
similar to Scala’s \code{for} notation. Roy does not address concerns such as event handling and DOM fragments
definition.

GWT~\cite{Chaganti07_GWT} compiles Java code to JavaScript. It exposes the browser’s APIs through type-safe Java APIs
and simplifies DOM fragments definition. However, it still uses a callback-driven programming model for asynchronous
computations.

Kotlin\footnote{\href{http://kotlin.jetbrains.org/}{http://kotlin.jetbrains.org/}} is a recent language written by
JetBrains, that targets both the JVM and JavaScript. It has libraries addressing partially Web programming concerns
and supports advanced programming language features such as mixins, type inference, variance annotations for type
parameters and pattern matching.

Opa\footnote{\href{http://opalang.org/}{http://opalang.org/}} is a language and a full stack designed for Web
programming. It features static typing with global type inference, modules and pattern matching. The language
provides a syntactic sugar for writing HTML fragments in the code. The server and client parts of an application can
be written in the Opa language, the system can decide whether a code fragment will run on server-side, client-side or
both. However, the Opa language is not extensible, so there is no way for developers to customize the compilation
process of their abstractions on client and server sides.

Dart~\cite{Griffith11_Dart} is a language designed specifically for Web programming. It has been designed to have a
familiar syntax for JavaScript developers and supports soft typing, classes and a module system. It also provides a
high-level concurrent programming system similar to an actor system. Finally, Dart code can be executed on both
client and server sides but the compiler is not extensible so developers cannot customize the compilation process of
a given abstraction on client and server sides.

Table \ref{comparison} gives a synthetic view of the comparison of our work with other mainstream approaches. Lines
give features desired to write large Web applications and colums list mainstream tools for Web programming. Cells
show the support level of each feature for each tool.

\begin{table}
\centering
\begin{tabular}{| l | c | c | c | c | c | c | c | c |}
\hline
& jQuery & TypeScript & Roy & GWT & Kotlin & Opa & Dart & js-scala \\
\hline
Type safe event handling & & & & *** & & & & *** \\
\hline
DOM definition & * & & & *** & ** & *** & * & *** \\
\hline
Asynchronous programming & ** & & *** & & & *** & ** & *** \\
\hline
Null references & ** & & *** & & * & ** & & *** \\
\hline
Type coercion & & & & * & * & * & * & *** \\
\hline
%General programming language features & * & ** & ** & * & *** & ? & * & *** \\
%\hline
Static typing & & * & ** & ** & ** & ** & * & ** \\
\hline
Easiness for defining libraries & ** & *** & *** & *** & *** & *** & *** & * \\
\hline
Client-server code sharing & & * & * & * & * & *  & * & *** \\
\hline
\end{tabular}
\caption{Support level of Web programming features by mainstream tools. Zero star means that the feature is not supported
at all, three stars mean a strong support.}
\label{comparison}
\end{table}

Several model-driven methodologies for creating web applications have been proposed, including
\cite{schwabe1996systematic,lima2003modeling,ceri2000web,koch2001authoring,pastor2003oows,valverde2007mda,vdovjak2003engineering,kraus2007model,nunes2006rapid,brambilla2008designing,valderas2007transformational,van2006hera,Groenewegen08_WebDSL}.
Many of them follow the standard top-down MDE vision in providing abstractions and code generators, nevertheless
these cannot be easily customized or generate only application skeletons.

\section{Conclusion and Perspectives}
\label{discussion}

Writing RIAs is challenging because they require a lot of logic on the client-side but the JavaScript language and
the Web browser’s native APIs make the code fragile and hard to reason about and to maintain.

We improved the js-scala DSL by adding first-class support for RIA concerns such as events handling,
DOM fragments definition and asynchronous programming. Our work provides a safer and more expressive language than
JavaScript and its native APIs to write RIAs but has no runtime overhead.

Future work will focus on the ability to choose where to execute a piece of code (on server-side or on client-side)
in order to be able to delay this choice until the runtime.

\bibliographystyle{ieeetr}
\bibliography{biblio}

\end{document}
